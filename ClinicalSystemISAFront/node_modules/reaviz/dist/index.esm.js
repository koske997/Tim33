import React, { Component, PureComponent, useMemo, cloneElement, Fragment, createRef, Children, useState, useRef, useEffect } from 'react';
import classNames from 'classnames';
import ellipsize from 'ellipsize';
import { max, min, bisector, range, median, histogram, extent as extent$1, maxIndex, sum } from 'd3-array';
import calculateSize from 'calculate-size';
import humanFormat from 'human-format';
import { curveMonotoneX, curveStep, curveLinear, stack, stackOffsetExpand, stackOffsetDiverging, arc, area, line, pie, radialArea, curveCardinalClosed, curveLinearClosed, radialLine } from 'd3-shape';
import { applyToPoint, inverse, applyToPoints, smoothMatrix, transform, translate as translate$1, scale, identity, fromDefinition, fromObject } from 'transformation-matrix';
import { scaleLinear, scaleTime, scaleBand, scaleOrdinal, scalePoint, scaleQuantile } from 'd3-scale';
import bind from 'memoize-bind';
import { withSize } from 'react-sizeme';
import bigInt from 'big-integer';
import chroma from 'chroma-js';
import { ConnectedOverlay } from 'rdk';
import { motion, useMotionValue, useSpring } from 'framer-motion';
import isEqual from 'is-equal';
import memoize from 'memoize-one';
import { interpolate as interpolate$1 } from 'd3-interpolate';
import { geoMercator, geoPath } from 'd3-geo';
import { sankey, sankeyJustify, sankeyCenter, sankeyLeft, sankeyRight, sankeyLinkHorizontal } from 'd3-sankey';
import CountUp from 'react-countup';

class LinearAxisTickLabel extends Component {
    getAlign() {
        const { align, half } = this.props;
        if ((align === 'inside' || align === 'outside') && half === 'center') {
            return 'center';
        }
        if (align === 'inside') {
            return half === 'start' ? 'end' : 'start';
        }
        if (align === 'outside') {
            return half === 'start' ? 'start' : 'end';
        }
        return align;
    }
    getTickLineSpacing() {
        const { line } = this.props;
        if (!line) {
            return [0, 0];
        }
        const size = line.props.size;
        const position = line.props.position;
        if (position === 'start') {
            return [size * -1, 0];
        }
        else if (position === 'end') {
            return [0, size];
        }
        else {
            return [size * -0.5, size * 0.5];
        }
    }
    getOffset() {
        const { padding, position, rotation, orientation } = this.props;
        const adjustedPadding = typeof padding === 'number'
            ? {
                fromAxis: padding,
                alongAxis: padding
            }
            : padding;
        const spacing = this.getTickLineSpacing();
        const offset1 = position === 'start'
            ? spacing[0] - adjustedPadding.fromAxis
            : position === 'end'
                ? spacing[1] + adjustedPadding.fromAxis
                : 0;
        const align = this.getAlign();
        let offset2 = rotation === true ? -5 : 0;
        offset2 +=
            align === 'center'
                ? 0
                : align === 'start'
                    ? -adjustedPadding.alongAxis
                    : adjustedPadding.alongAxis;
        const horz = orientation === 'horizontal';
        return {
            [horz ? 'x' : 'y']: offset2,
            [horz ? 'y' : 'x']: offset1
        };
    }
    getTextPosition() {
        const { angle, orientation, position } = this.props;
        let transform = '';
        let textAnchor = '';
        let alignmentBaseline = 'middle';
        if (angle !== 0) {
            transform = `rotate(${angle})`;
            textAnchor = 'end';
        }
        else {
            const align = this.getAlign();
            if (orientation === 'horizontal') {
                textAnchor =
                    align === 'center' ? 'middle' : align === 'start' ? 'end' : 'start';
                if (position === 'start') {
                    alignmentBaseline = 'baseline';
                }
                else if (position === 'end') {
                    alignmentBaseline = 'hanging';
                }
            }
            else {
                alignmentBaseline =
                    align === 'center'
                        ? 'middle'
                        : align === 'start'
                            ? 'baseline'
                            : 'hanging';
                if (position === 'start') {
                    textAnchor = 'end';
                }
                else if (position === 'end') {
                    textAnchor = 'start';
                }
                else {
                    textAnchor = 'middle';
                }
            }
        }
        return {
            transform,
            textAnchor: this.props.textAnchor || textAnchor,
            alignmentBaseline
        };
    }
    render() {
        const { fill, text, fullText, fontSize, fontFamily, className } = this.props;
        const { x, y } = this.getOffset();
        const textPosition = this.getTextPosition();
        return (React.createElement("g", { transform: `translate(${x}, ${y})`, fontSize: fontSize, fontFamily: fontFamily },
            React.createElement("title", null, fullText),
            React.createElement("text", Object.assign({}, textPosition, { fill: fill, className: className }), text)));
    }
}
LinearAxisTickLabel.defaultProps = {
    fill: '#8F979F',
    fontSize: 11,
    fontFamily: 'sans-serif',
    rotation: true,
    padding: 0,
    align: 'center'
};

class LinearAxisTickLine extends PureComponent {
    positionTick() {
        const { size, position, orientation } = this.props;
        const isVertical = orientation === 'vertical';
        const tickSize = size || 0;
        const start = position === 'start'
            ? tickSize * -1
            : position === 'center'
                ? tickSize * -0.5
                : 0;
        const end = start + tickSize;
        return {
            x1: isVertical ? end : 0,
            x2: isVertical ? start : 0,
            y1: isVertical ? 0 : start,
            y2: isVertical ? 0 : end
        };
    }
    render() {
        const { strokeColor, strokeWidth, className } = this.props;
        const path = this.positionTick();
        return (React.createElement("line", Object.assign({ className: className, strokeWidth: strokeWidth, stroke: strokeColor }, path)));
    }
}
LinearAxisTickLine.defaultProps = {
    strokeColor: '#8F979F',
    strokeWidth: 1,
    size: 5
};

// https://stackoverflow.com/questions/673905/best-way-to-determine-users-locale-within-browser
const getNavigatorLanguage = () => {
    if (typeof window === 'undefined') {
        return 'en';
    }
    if (navigator.languages && navigator.languages.length) {
        return navigator.languages[0];
    }
    if (navigator.userLanguage ||
        navigator.language ||
        navigator.browserLanguage) {
        return 'en';
    }
};
const locale = getNavigatorLanguage();
const options = {
    year: 'numeric',
    month: 'numeric',
    day: 'numeric',
    hour12: true,
    formatMatcher: 'best fit'
};
/**
 * Format a value based on type.
 */
function formatValue(value) {
    if (value !== undefined) {
        if (value instanceof Date) {
            return value.toLocaleDateString(locale, options);
        }
        else if (typeof value === 'number') {
            return value.toLocaleString();
        }
        return value;
    }
    return 'No value';
}

const ONE_DAY = 60 * 60 * 24;
const DURATION_TICK_STEPS = [
    0.001,
    0.005,
    0.01,
    0.05,
    0.1,
    0.5,
    1,
    5,
    10,
    15,
    60,
    60 * 15,
    60 * 30,
    60 * 60,
    60 * 60 * 2,
    60 * 60 * 4,
    60 * 60 * 6,
    60 * 60 * 8,
    60 * 60 * 12,
    ONE_DAY // 24 h
];
/**
 * Reduce the ticks to the max number of ticks.
 */
function reduceTicks(ticks, maxTicks) {
    if (ticks.length > maxTicks) {
        const reduced = [];
        const modulus = Math.floor(ticks.length / maxTicks);
        for (let i = 0; i < ticks.length; i++) {
            if (i % modulus === 0) {
                reduced.push(ticks[i]);
            }
        }
        ticks = reduced;
    }
    return ticks;
}
/**
 * Determine the max ticks for the available width.
 */
function getMaxTicks(size, dimension) {
    const tickWidth = Math.max(size, 0);
    return Math.floor(dimension / tickWidth);
}
/**
 * Formats the ticks in a duration format.
 */
function getDurationTicks(domain, maxTicks) {
    const domainWidth = domain[1] - domain[0];
    let tickStep = null;
    for (const s of DURATION_TICK_STEPS) {
        if (domainWidth / s < maxTicks) {
            tickStep = s;
            break;
        }
    }
    if (tickStep === null) {
        const numDayTicks = domainWidth / ONE_DAY;
        const dayStep = Math.ceil(numDayTicks / maxTicks);
        tickStep = ONE_DAY * dayStep;
    }
    const ticks = [domain[0]];
    while (ticks[ticks.length - 1] + tickStep <= domain[1]) {
        ticks.push(ticks[ticks.length - 1] + tickStep);
    }
    return ticks;
}
/**
 * Get the tick values from the scale.
 */
function getTicks(scale, tickValues, type, maxTicks = 100, interval) {
    let result;
    if (tickValues) {
        result = tickValues;
    }
    else {
        if (scale.ticks) {
            if (type === 'duration') {
                result = getDurationTicks(scale.domain(), maxTicks);
            }
            else if (interval) {
                result = scale.ticks(interval);
            }
            else {
                if (type === 'time') {
                    // If its time, we need to handle the time count
                    // manually because d3 does this odd rounding
                    result = scale.ticks();
                    result = reduceTicks(result, maxTicks);
                }
                else {
                    result = scale.ticks(maxTicks);
                }
            }
        }
        else {
            tickValues = scale.domain();
            result = reduceTicks(tickValues, maxTicks);
        }
    }
    return result;
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

/**
 * CloneElement is a wrapper component for createElement function.
 * This allows you to describe your cloning element declaratively
 * which is a more natural API for React.
 */
function CloneElement(_a) {
    var { children, element, childRef } = _a, rest = __rest(_a, ["children", "element", "childRef"]);
    const getProjectedProps = useMemo(() => props => {
        const childProps = element.props;
        return Object.keys(props).reduce((acc, key) => {
            const prop = props[key];
            const childProp = childProps[key];
            if (typeof prop === 'function' && typeof childProp === 'function') {
                acc[key] = args => {
                    prop(args);
                    childProp(args);
                };
            }
            else if (key === 'className') {
                acc[key] = classNames(prop, childProp);
            }
            else {
                acc[key] = prop;
            }
            return acc;
        }, {});
    }, [rest]);
    if (element === null) {
        return children;
    }
    // Tricky logic around functional vs class components
    const ref = childRef ?
        node => {
            if (typeof childRef === 'function') {
                childRef(node);
            }
            else if (ref) {
                childRef.current = node;
            }
        } : undefined;
    const newProps = getProjectedProps(rest);
    return cloneElement(element, Object.assign(Object.assign(Object.assign({}, element.props), newProps), { children,
        ref }));
}

const calculateDimensions = (text, fontFamily, fontSize) => {
    // SSR Rendering doesn't support canvas measurements
    // we have to make a guess in this case...
    if (typeof document === 'undefined') {
        return {
            width: text.length * 8,
            height: 25
        };
    }
    return calculateSize(text, {
        font: fontFamily,
        fontSize: `${fontSize}px`
    });
};

class LinearAxisTickSeries extends Component {
    /**
     * Gets the adjusted scale given offsets.
     */
    getAdjustedScale() {
        const { scale } = this.props;
        if (scale.bandwidth) {
            let offset = scale.bandwidth() / 2;
            if (scale.round()) {
                offset = Math.round(offset);
            }
            return d => +scale(d) + offset;
        }
        else {
            return d => +scale(d);
        }
    }
    /**
     * Gets the x/y position for a given tick.
     */
    getPosition(scaledTick) {
        const { orientation } = this.props;
        if (orientation === 'horizontal') {
            return { x: scaledTick, y: 0 };
        }
        else {
            return { x: 0, y: scaledTick };
        }
    }
    /**
     * Gets the dimension (height/width) this axis is calculating on.
     */
    getDimension() {
        const { height, width, orientation } = this.props;
        return orientation === 'vertical' ? height : width;
    }
    /**
     * Calculates the rotation angle that the ticks need to be shifted to.
     * This equation will measure the length of the text in a external canvas
     * object and determine what the longest label is and rotate until they fit.
     */
    getRotationAngle(ticks) {
        if (!this.props.label) {
            return 0;
        }
        const label = this.props.label.props;
        const dimension = this.getDimension();
        const maxTicksLength = max(ticks, tick => tick.width);
        let angle = 0;
        if (label.rotation) {
            if (label.rotation === true) {
                let baseWidth = maxTicksLength;
                const maxBaseWidth = Math.floor(dimension / ticks.length);
                while (baseWidth > maxBaseWidth && angle > -90) {
                    angle -= 30;
                    baseWidth = Math.cos(angle * (Math.PI / 180)) * maxTicksLength;
                }
            }
            else {
                angle = label.rotation;
            }
        }
        return angle;
    }
    /**
     * Gets the formatted label of the tick.
     */
    getLabelFormat() {
        const { label, scale } = this.props;
        if (label && label.props.format) {
            return label.props.format;
        }
        else if (scale.tickFormat) {
            return scale.tickFormat.apply(scale, [5]);
        }
        else {
            return v => formatValue(v);
        }
    }
    /**
     * Gets the ticks given the dimensions and scales and returns
     * the text and position.
     */
    getTicks() {
        const { scale, tickSize, tickValues, interval, axis, label } = this.props;
        const dimension = this.getDimension();
        const maxTicks = getMaxTicks(tickSize, dimension);
        const ticks = getTicks(scale, tickValues, axis.type, maxTicks, interval);
        const adjustedScale = this.getAdjustedScale();
        const format = this.getLabelFormat();
        const midpoint = dimension / 2;
        return ticks.map(tick => {
            const fullText = format(tick);
            const scaledTick = adjustedScale(tick);
            const position = this.getPosition(scaledTick);
            const text = ellipsize(fullText, 18);
            const size = label
                ? calculateDimensions(text, label.props.fontFamily, label.props.fontSize.toString())
                : {};
            return Object.assign(Object.assign(Object.assign({}, position), size), { text,
                fullText, half: scaledTick === midpoint
                    ? 'center'
                    : scaledTick < midpoint
                        ? 'start'
                        : 'end' });
        });
    }
    render() {
        const { label, line, height, width, orientation } = this.props;
        const ticks = this.getTicks();
        const angle = this.getRotationAngle(ticks);
        return (React.createElement(Fragment, null, ticks.map((tick, i) => (React.createElement("g", { key: i, transform: `translate(${tick.x}, ${tick.y})` },
            line && (React.createElement(CloneElement, { element: line, height: height, width: width, orientation: orientation })),
            label && (React.createElement(CloneElement, { element: label, text: tick.text, fullText: tick.fullText, half: tick.half, angle: angle, orientation: orientation, line: line })))))));
    }
}
LinearAxisTickSeries.defaultProps = {
    line: React.createElement(LinearAxisTickLine, null),
    label: React.createElement(LinearAxisTickLabel, null),
    tickSize: 30
};

const humanFormatScale = new humanFormat.Scale({
    k: 1000,
    M: 1000000,
    B: 1000000000
});
const humanFormatMillionScale = new humanFormat.Scale({
    M: 1,
    B: 1000,
    T: 1000000
});
const ONE_MILLION = 1000000;
const ONE_BILLION = 1000000000;
const humanFormatBigInteger = bigInteger => {
    if (bigInteger.greater(ONE_BILLION)) {
        return humanFormat(bigInteger.divide(ONE_MILLION).toJSNumber(), {
            scale: humanFormatMillionScale
        });
    }
    return humanFormat(bigInteger.toJSNumber(), { scale: humanFormatScale });
};
const bigIntegerToLocaleString = bigInteger => {
    let i = 0;
    let formattedString = '';
    for (const c of bigInteger
        .toString()
        .split('')
        .reverse()) {
        if (i > 0 && i % 3 === 0) {
            formattedString = ',' + formattedString;
        }
        formattedString = c + formattedString;
        i++;
    }
    return formattedString;
};

/**
 * Given a margins object, returns the top/left/right/bottom positions.
 */
function parseMargins(margins) {
    let top = 0;
    let right = 0;
    let bottom = 0;
    let left = 0;
    if (Array.isArray(margins)) {
        if (margins.length === 2) {
            top = margins[0];
            bottom = margins[0];
            left = margins[1];
            right = margins[1];
        }
        else if (margins.length === 4) {
            top = margins[0];
            right = margins[1];
            bottom = margins[2];
            left = margins[3];
        }
    }
    else if (margins !== undefined) {
        top = margins;
        right = margins;
        bottom = margins;
        left = margins;
    }
    return {
        top,
        right,
        bottom,
        left
    };
}
/**
 * Calculates the margins for the chart.
 */
function calculateMarginOffsets(height, width, margins) {
    const { left, right, bottom, top } = margins;
    const newHeight = height - top - bottom;
    const newWidth = width - left - right;
    return {
        height: newHeight,
        width: newWidth
    };
}
/**
 * Calculates the dimensions for the chart.
 */
function getDimension({ xOffset, yOffset, height, width, margins }) {
    const parsedMargins = parseMargins(margins);
    const marginDims = calculateMarginOffsets(height, width, parsedMargins);
    const chartWidth = marginDims.width - xOffset;
    const chartHeight = marginDims.height - yOffset;
    return {
        xOffset,
        yOffset,
        height,
        width,
        chartWidth,
        chartHeight,
        xMargin: xOffset + parsedMargins.left,
        yMargin: parsedMargins.top
    };
}

/**
 * Gets the min/max values handling nested arrays.
 */
function extent(data, attr) {
    const accessor = (val, fn) => {
        if (Array.isArray(val.data)) {
            return fn(val.data, vv => vv[attr]);
        }
        return val[attr];
    };
    const minVal = min(data, d => accessor(d, min));
    const maxVal = max(data, d => accessor(d, max));
    return [minVal, maxVal];
}
/**
 * Get the domain for the Y Axis.
 */
function getYDomain({ data, scaled = false, isDiverging = false }) {
    const [startY, endY] = extent(data, 'y');
    const [startY1, endY1] = extent(data, 'y1');
    // If dealing w/ negative numbers, we should
    // normalize the top and bottom values
    if (startY < 0 || isDiverging) {
        const posStart = -startY;
        const maxNum = Math.max(posStart, endY);
        return [-maxNum, maxNum];
    }
    // Scaled start scale at non-zero
    if (scaled) {
        return [startY1, endY1];
    }
    // Start at 0 based
    return [0, endY1];
}
/**
 * Get the domain for the X Axis.
 */
function getXDomain({ data, scaled = false, isDiverging = false }) {
    const startX0 = extent(data, 'x0')[0];
    const endX1 = extent(data, 'x1')[1];
    // Histograms use dates for start/end
    if (typeof startX0 === 'number' && typeof endX1 === 'number') {
        // If dealing w/ negative numbers, we should
        // normalize the top and bottom values
        if (startX0 < 0 || isDiverging) {
            const posStart = -startX0;
            const maxNum = Math.max(posStart, endX1);
            return [-maxNum, maxNum];
        }
        // If not scaled, return 0/max domains
        if (!scaled) {
            return [0, endX1];
        }
    }
    // Scaled start scale at non-zero
    return [startX0, endX1];
}

/**
 * Helper function for interpolation.
 */
function interpolate(type) {
    if (type === 'smooth') {
        return curveMonotoneX;
    }
    else if (type === 'step') {
        return curveStep;
    }
    else {
        return curveLinear;
    }
}

/**
 * Add ability to calculate scale band position.
 * Reference: https://stackoverflow.com/questions/38633082/d3-getting-invert-value-of-band-scales
 */
const scaleBandInvert = scale => {
    const domain = scale.domain();
    const paddingOuter = scale(domain[0]);
    const eachBand = scale.step();
    const [, end] = scale.range();
    return offset => {
        let index = Math.floor((offset - paddingOuter) / eachBand);
        // Handle horizontal charts...
        if (end === 0) {
            index = index * -1;
        }
        return domain[Math.max(0, Math.min(index, domain.length - 1))];
    };
};
/**
 * Given a point position, get the closes data point in the dataset.
 */
const getClosestPoint = (pos, scale, data, attr = 'x') => {
    if (scale.invert) {
        const domain = scale.invert(pos);
        // Select the index
        const bisect = bisector((d) => d[attr]).right;
        const index = bisect(data, domain);
        // Determine min index
        const minIndex = Math.max(0, index - 1);
        const before = data[minIndex];
        // Determine max index
        const maxIndex = Math.min(data.length - 1, index);
        const after = data[maxIndex];
        // Determine which is closest to the point
        let beforeVal = before[attr];
        let afterVal = after[attr];
        beforeVal = domain - beforeVal;
        afterVal = afterVal - domain;
        return beforeVal < afterVal ? before : after;
    }
    else {
        // If we have a band scale, handle that special
        const domain = scale.domain();
        let prop;
        // Of course the Marimekko is a pain...
        if (scale.mariemkoInvert) {
            prop = scale.mariemkoInvert(pos);
        }
        else {
            prop = scaleBandInvert(scale)(pos);
        }
        const idx = domain.indexOf(prop);
        return data[idx];
    }
};
/**
 * Given an event, get the parent svg element;
 */
const getParentSVG = event => {
    // set node to targets owner svg
    let node = event.target.ownerSVGElement;
    // find the outermost svg
    if (node) {
        while (node.ownerSVGElement) {
            node = node.ownerSVGElement;
        }
    }
    return node;
};
/**
 * Given an event, get the relative X/Y position for a target.
 */
const getPositionForTarget = ({ target, clientX, clientY }) => {
    const { top, left } = target.getBoundingClientRect();
    return {
        x: clientX - left - target.clientLeft,
        y: clientY - top - target.clientTop
    };
};
/**
 * Gets the point from q given matrix.
 */
const getPointFromMatrix = (event, matrix) => {
    const parent = getParentSVG(event);
    if (!parent) {
        return null;
    }
    // Determines client coordinates relative to the editor component
    const { top, left } = parent.getBoundingClientRect();
    const x = event.clientX - left;
    const y = event.clientY - top;
    // Transforms the coordinate to world coordinate (in the SVG/DIV world)
    return applyToPoint(inverse(matrix), { x, y });
};
/**
 * Get the start/end matrix.
 */
const getLimitMatrix = (height, width, matrix) => applyToPoints(matrix, [
    { x: 0, y: 0 },
    { x: width, y: height }
]);
/**
 * Constrain the matrix.
 */
const constrainMatrix = (height, width, matrix) => {
    const [min, max] = getLimitMatrix(height, width, matrix);
    if (max.x < width || max.y < height) {
        return true;
    }
    if (min.x > 0 || min.y > 0) {
        return true;
    }
    return false;
};
/**
 * Determine if scale factor is less than allowed.
 */
const lessThanScaleFactorMin = (value, scaleFactor) => value.scaleFactorMin && value.d * scaleFactor <= value.scaleFactorMin;
/**
 * Determine if scale factor is larger than allowed.
 */
const moreThanScaleFactorMax = (value, scaleFactor) => value.scaleFactorMax && value.d * scaleFactor >= value.scaleFactorMax;
/**
 * Determine if both min and max scale fctors are going out of bounds.
 */
const isZoomLevelGoingOutOfBounds = (value, scaleFactor) => {
    const a = lessThanScaleFactorMin(value, scaleFactor) && scaleFactor < 1;
    const b = moreThanScaleFactorMax(value, scaleFactor) && scaleFactor > 1;
    return a || b;
};

/**
 * Toggle the text selection of the body.
 */
function toggleTextSelection(allowSelection) {
    const style = allowSelection ? '' : 'none';
    [
        '-webkit-touch-callout',
        '-webkit-user-select',
        '-khtml-user-select',
        '-moz-user-select',
        '-ms-user-select',
        'user-select'
    ].forEach(prop => (document.body.style[prop] = style));
}

/**
 * Calculates whether the stroke should be shown.
 */
function calculateShowStroke(current, data) {
    const i = data.indexOf(current);
    let showLine = false;
    const prev = data[i - 1];
    if (i > 0 && prev.y) {
        showLine = true;
    }
    const cur = data[i];
    if (cur.y) {
        showLine = true;
    }
    const next = data[i + 1];
    if (i < data.length - 1 && next.y) {
        showLine = true;
    }
    return showLine;
}

/**
 * Get the angle from a radian.
 */
const getDegrees = (radians) => (radians / Math.PI) * 180 - 90;

const functionProps = (prop, val, data) => {
    if (typeof val === 'function') {
        return val(data);
    }
    else if (prop === 'className') {
        return classNames(val);
    }
    else if (val !== undefined || val !== null) {
        return val;
    }
    return {};
};
const constructFunctionProps = (props, data) => ({
    className: functionProps('className', props.className, data),
    style: functionProps('style', props.style, data)
});

/**
 * Given a dataset and a list of accessors, returns a unique collection.
 */
function uniqueBy(data, ...accessors) {
    const result = [];
    const ittr = (arr, depth) => {
        for (const a of arr) {
            const acc = accessors[depth];
            if (acc === undefined) {
                throw new Error(`Accessor not found for depth: ${depth}`);
            }
            const val = acc(a);
            if (Array.isArray(val)) {
                ittr(val, depth + 1);
            }
            else if (!result.includes(val)) {
                result.push(val);
            }
        }
    };
    ittr(data, 0);
    return result;
}

let axisLineId = 0;
class LinearAxisLine extends Component {
    constructor() {
        super(...arguments);
        this.state = {
            id: (axisLineId++).toString()
        };
    }
    render() {
        const { strokeColor, strokeGradient, scale, orientation, className } = this.props;
        const { id } = this.state;
        const [range0, range1] = scale.range();
        return (React.createElement(Fragment, null,
            React.createElement("line", { className: className, x1: orientation === 'vertical' ? 0 : range0, 
                // Workaround for a Chrome/Firefox bug where it won't render gradients for straight lines
                x2: orientation === 'vertical' ? 0.00001 : range1, y1: orientation === 'vertical' ? range0 : 0, y2: orientation === 'vertical' ? range1 : 0.00001, strokeWidth: 1, stroke: strokeGradient ? `url(#axis-gradient-${id})` : strokeColor }),
            strokeGradient && (React.createElement(CloneElement, { element: strokeGradient, id: `axis-gradient-${id}` }))));
    }
}
LinearAxisLine.defaultProps = {
    strokeColor: '#8F979F',
    strokeWidth: 1
};

class LinearAxis extends Component {
    constructor(props) {
        super(props);
        this.ref = createRef();
        this.state = {
            height: props.height,
            width: props.width
        };
    }
    componentDidMount() {
        this.updateDimensions();
    }
    componentDidUpdate(prevProps) {
        const { height, width, scale } = this.props;
        if (width !== prevProps.width ||
            height !== prevProps.height ||
            scale !== prevProps.scale) {
            this.updateDimensions();
        }
    }
    updateDimensions() {
        const { onDimensionsChange, orientation, position } = this.props;
        const shouldOffset = position !== 'center';
        let height;
        let width;
        if (shouldOffset) {
            const dims = this.ref.current.getBoundingClientRect();
            width = Math.floor(dims.width);
            height = Math.floor(dims.height);
        }
        if (orientation === 'vertical') {
            if (this.state.width !== width) {
                this.setState({ width });
                onDimensionsChange({ width });
            }
        }
        else {
            if (this.state.height !== height) {
                this.setState({ height });
                onDimensionsChange({ height });
            }
        }
    }
    getPosition() {
        const { position, width, height, orientation } = this.props;
        let translateY = 0;
        let translateX = 0;
        if (position === 'end' && orientation === 'horizontal') {
            translateY = height;
        }
        else if (position === 'center' && orientation === 'horizontal') {
            translateY = height / 2;
        }
        else if (position === 'end' && orientation === 'vertical') {
            translateX = width;
        }
        else if (position === 'center' && orientation === 'vertical') {
            translateX = width / 2;
        }
        return { translateX, translateY };
    }
    render() {
        const { scale, height, width, orientation, axisLine, tickSeries } = this.props;
        const { translateX, translateY } = this.getPosition();
        return (React.createElement("g", { transform: `translate(${translateX}, ${translateY})`, ref: this.ref },
            axisLine && (React.createElement(CloneElement, { element: axisLine, height: height, width: width, scale: scale, orientation: orientation })),
            (tickSeries.props.line || tickSeries.props.label) && (React.createElement(CloneElement, { element: tickSeries, height: height, width: width, scale: scale, orientation: orientation, axis: this.props }))));
    }
}
LinearAxis.defaultProps = {
    axisLine: React.createElement(LinearAxisLine, null),
    tickSeries: React.createElement(LinearAxisTickSeries, null),
    scaled: false,
    roundDomains: false,
    onDimensionsChange: () => undefined
};

class LinearXAxisTickLabel extends Component {
    render() {
        return React.createElement(LinearAxisTickLabel, Object.assign({}, this.props));
    }
}
LinearXAxisTickLabel.defaultProps = Object.assign(Object.assign({}, LinearAxisTickLabel.defaultProps), { rotation: true, position: 'end', align: 'center' });
class LinearXAxisTickLine extends Component {
    render() {
        return React.createElement(LinearAxisTickLine, Object.assign({}, this.props));
    }
}
LinearXAxisTickLine.defaultProps = Object.assign(Object.assign({}, LinearAxisTickLine.defaultProps), { position: 'end' });
class LinearXAxisTickSeries extends Component {
    render() {
        return React.createElement(LinearAxisTickSeries, Object.assign({}, this.props));
    }
}
LinearXAxisTickSeries.defaultProps = Object.assign(Object.assign({}, LinearAxisTickSeries.defaultProps), { tickSize: 75, line: React.createElement(LinearXAxisTickLine, null), label: React.createElement(LinearXAxisTickLabel, null) });
class LinearXAxis extends Component {
    render() {
        return React.createElement(LinearAxis, Object.assign({}, this.props));
    }
}
LinearXAxis.defaultProps = Object.assign(Object.assign({}, LinearAxis.defaultProps), { position: 'end', roundDomains: false, scaled: false, type: 'value', orientation: 'horizontal', tickSeries: React.createElement(LinearXAxisTickSeries, null) });

class LinearYAxisTickLabel extends Component {
    render() {
        return React.createElement(LinearAxisTickLabel, Object.assign({}, this.props));
    }
}
LinearYAxisTickLabel.defaultProps = Object.assign(Object.assign({}, LinearAxisTickLabel.defaultProps), { rotation: false, position: 'start', align: 'center' });
class LinearYAxisTickLine extends Component {
    render() {
        return React.createElement(LinearAxisTickLine, Object.assign({}, this.props));
    }
}
LinearYAxisTickLine.defaultProps = Object.assign(Object.assign({}, LinearAxisTickLine.defaultProps), { position: 'start' });
class LinearYAxisTickSeries extends Component {
    render() {
        return React.createElement(LinearAxisTickSeries, Object.assign({}, this.props));
    }
}
LinearYAxisTickSeries.defaultProps = Object.assign(Object.assign({}, LinearAxisTickSeries.defaultProps), { tickSize: 30, line: React.createElement(LinearYAxisTickLine, null), label: React.createElement(LinearYAxisTickLabel, null) });
class LinearYAxis extends Component {
    render() {
        return React.createElement(LinearAxis, Object.assign({}, this.props));
    }
}
LinearYAxis.defaultProps = Object.assign(Object.assign({}, LinearAxis.defaultProps), { orientation: 'vertical', scaled: false, roundDomains: false, type: 'value', position: 'start', tickSeries: React.createElement(LinearYAxisTickSeries, null) });

/**
 * Returns whether the axis has a visual element or not.
 */
const isAxisVisible = (axis) => !!axis.tickSeries.props.label || !!axis.tickSeries.props.line;

class RadialAxisTickLine extends PureComponent {
    render() {
        const { stroke, size, position, innerRadius, outerRadius } = this.props;
        const x1 = position === 'outside' ? size : -(outerRadius - innerRadius);
        return (React.createElement("line", { x1: x1, x2: 0, stroke: stroke, style: { pointerEvents: 'none' } }));
    }
}
RadialAxisTickLine.defaultProps = {
    stroke: 'rgba(113, 128, 141, .5)',
    size: 10,
    position: 'inside'
};

const rad2deg = (angle) => (angle * 180) / Math.PI;
class RadialAxisTickLabel extends PureComponent {
    getPosition() {
        const { point, autoRotate, rotation, padding } = this.props;
        let textAnchor;
        let transform;
        if (autoRotate) {
            const l = point >= Math.PI;
            const r = point < 2 * Math.PI;
            // TODO: This centers the text, determine better way later
            if ((rotation >= 85 && rotation <= 95) ||
                (rotation <= -85 && rotation >= -95)) {
                textAnchor = 'middle';
            }
            else if (l && r) {
                textAnchor = 'end';
            }
            else {
                textAnchor = 'start';
            }
            transform = `rotate(${90 - rad2deg(point)}, ${padding}, 0)`;
        }
        else {
            const shouldRotate = rotation > 100 && rotation;
            const rotate = shouldRotate ? 180 : 0;
            const translate = shouldRotate ? -30 : 0;
            textAnchor = shouldRotate ? 'end' : 'start';
            transform = `rotate(${rotate}) translate(${translate})`;
        }
        return {
            transform,
            textAnchor
        };
    }
    render() {
        const { data, fill, fontFamily, fontSize, format, lineSize, index } = this.props;
        const text = format ? format(data, index) : formatValue(data);
        const { transform, textAnchor } = this.getPosition();
        return (React.createElement("g", { transform: transform },
            React.createElement("title", null, text),
            React.createElement("text", { dy: "0.35em", x: lineSize + 5, textAnchor: textAnchor, fill: fill, fontFamily: fontFamily, fontSize: fontSize }, text)));
    }
}
RadialAxisTickLabel.defaultProps = {
    fill: '#71808d',
    fontSize: 11,
    padding: 15,
    fontFamily: 'sans-serif',
    autoRotate: true
};

class RadialAxisTick extends Component {
    render() {
        const { line, label, scale, outerRadius, data, index, padding, innerRadius } = this.props;
        const point = scale(data);
        const rotation = (point * 180) / Math.PI - 90;
        const transform = `rotate(${rotation}) translate(${outerRadius +
            padding},0)`;
        const lineSize = line ? line.props.size : 0;
        return (React.createElement("g", { transform: transform },
            line && (React.createElement(CloneElement, { element: line, innerRadius: innerRadius, outerRadius: outerRadius })),
            label && (React.createElement(CloneElement, { element: label, index: index, point: point, rotation: rotation, lineSize: lineSize, data: data }))));
    }
}
RadialAxisTick.defaultProps = {
    outerRadius: 0,
    padding: 0,
    line: React.createElement(RadialAxisTickLine, null),
    label: React.createElement(RadialAxisTickLabel, null)
};

class RadialAxisTickSeries extends Component {
    render() {
        const { scale, count, outerRadius, tick, tickValues, innerRadius, interval } = this.props;
        const ticks = getTicks(scale, tickValues, 'time', count, interval || count);
        return (React.createElement(Fragment, null, ticks.map((data, i) => (React.createElement(CloneElement, { element: tick, key: i, index: i, scale: scale, data: data, innerRadius: innerRadius, outerRadius: outerRadius })))));
    }
}
RadialAxisTickSeries.defaultProps = {
    count: 12,
    tick: React.createElement(RadialAxisTick, null)
};

class RadialAxisArc extends Component {
    render() {
        const { index, stroke, strokeDasharray, scale } = this.props;
        const r = scale(index);
        const strokeColor = typeof stroke === 'string' ? stroke : stroke(index);
        const strokeDash = typeof strokeDasharray === 'string'
            ? strokeDasharray
            : strokeDasharray(index);
        return (React.createElement("circle", { fill: "none", strokeDasharray: strokeDash, stroke: strokeColor, style: { pointerEvents: 'none' }, cx: "0", cy: "0", r: r }));
    }
}
RadialAxisArc.defaultProps = {
    stroke: '#71808d',
    strokeDasharray: '1,4'
};

class RadialAxisArcSeries extends Component {
    render() {
        const { count, innerRadius, outerRadius, arc } = this.props;
        const scale = scaleLinear()
            .domain([0, count])
            .range([innerRadius, outerRadius]);
        const arcs = scale.ticks(count);
        return (React.createElement(Fragment, null, arcs.map(d => (React.createElement(CloneElement, { element: arc, key: d, index: d, scale: scale })))));
    }
}
RadialAxisArcSeries.defaultProps = {
    count: 12,
    arc: React.createElement(RadialAxisArc, null)
};

class RadialAxis extends Component {
    render() {
        const { arcs, ticks, xScale, height, width, innerRadius } = this.props;
        const outerRadius = Math.min(height, width) / 2;
        return (React.createElement(Fragment, null,
            arcs && (React.createElement(CloneElement, { element: arcs, outerRadius: outerRadius, innerRadius: innerRadius })),
            ticks && (React.createElement(CloneElement, { element: ticks, scale: xScale, innerRadius: innerRadius, outerRadius: outerRadius }))));
    }
}
RadialAxis.defaultProps = {
    innerRadius: 10,
    arcs: React.createElement(RadialAxisArcSeries, null),
    ticks: React.createElement(RadialAxisTickSeries, null)
};

class Move extends Component {
    constructor() {
        super(...arguments);
        this.started = false;
        this.deltaX = 0;
        this.deltaY = 0;
        this.prevXPosition = 0;
        this.prevYPosition = 0;
        this.onMouseMove = event => {
            event.preventDefault();
            event.stopPropagation();
            const { movementX, movementY } = event;
            this.deltaX = this.deltaX + movementX;
            this.deltaY = this.deltaY + movementY;
            if (this.checkThreshold()) {
                this.disableText(true);
                this.setCursor(true);
                this.deltaX = 0;
                this.deltaY = 0;
                this.started = true;
                this.props.onMoveStart({
                    nativeEvent: event,
                    type: 'mouse'
                });
            }
            else {
                this.rqf = requestAnimationFrame(() => {
                    this.props.onMove({
                        nativeEvent: event,
                        type: 'mouse',
                        x: movementX,
                        y: movementY
                    });
                });
            }
        };
        this.onMouseUp = event => {
            event.preventDefault();
            event.stopPropagation();
            this.disposeHandlers();
            if (this.started) {
                this.props.onMoveEnd({
                    nativeEvent: event,
                    type: 'mouse'
                });
            }
            else {
                this.props.onMoveCancel({
                    nativeEvent: event,
                    type: 'mouse'
                });
            }
        };
        this.onTouchMove = (event) => {
            event.preventDefault();
            event.stopPropagation();
            // Calculate delta from previous position and current
            const { clientX, clientY } = this.getTouchCoords(event);
            const deltaX = clientX - this.prevXPosition;
            const deltaY = clientY - this.prevYPosition;
            // Track the delta
            this.deltaX = this.deltaX + deltaX;
            this.deltaY = this.deltaY + deltaY;
            if (this.checkThreshold()) {
                this.disableText(true);
                this.setCursor(true);
                this.deltaX = 0;
                this.deltaY = 0;
                this.started = true;
                this.props.onMoveStart({
                    // TODO: Come back and clean this up...
                    nativeEvent: Object.assign(Object.assign({}, event), { clientX,
                        clientY }),
                    type: 'touch'
                });
            }
            else {
                this.rqf = requestAnimationFrame(() => {
                    this.props.onMove({
                        // TODO: Come back and clean this up...
                        nativeEvent: Object.assign(Object.assign({}, event), { clientX,
                            clientY }),
                        type: 'touch',
                        x: deltaX,
                        y: deltaY
                    });
                });
            }
            this.prevXPosition = clientX;
            this.prevYPosition = clientY;
        };
        this.onTouchEnd = (event) => {
            event.preventDefault();
            event.stopPropagation();
            this.disposeHandlers();
            if (this.started) {
                this.props.onMoveEnd({
                    nativeEvent: event,
                    type: 'touch'
                });
            }
            else {
                this.props.onMoveCancel({
                    nativeEvent: event,
                    type: 'touch'
                });
            }
        };
    }
    componentWillUnmount() {
        cancelAnimationFrame(this.rqf);
        this.disposeHandlers();
    }
    disposeHandlers() {
        window.removeEventListener('mousemove', this.onMouseMove);
        window.removeEventListener('mouseup', this.onMouseUp);
        window.removeEventListener('touchmove', this.onTouchMove);
        window.removeEventListener('touchend', this.onTouchEnd);
        this.setCursor(false);
        this.disableText(true);
    }
    disableText(shouldDisable) {
        if (this.props.disableText) {
            toggleTextSelection(shouldDisable);
        }
    }
    setCursor(set) {
        let { cursor } = this.props;
        if (cursor) {
            if (!set) {
                cursor = 'inherit';
            }
            document.body.style['cursor'] = cursor;
        }
    }
    checkThreshold() {
        const { threshold } = this.props;
        return (!this.started &&
            (Math.abs(this.deltaX) > threshold || Math.abs(this.deltaY) > threshold));
    }
    getTouchCoords(event) {
        const { clientX, clientY } = event.touches[0];
        return {
            clientX,
            clientY
        };
    }
    onMouseDown(event) {
        const { preventRightClick, disabled } = this.props;
        const shouldCancel = event.nativeEvent.which === 3 && preventRightClick;
        if (shouldCancel || disabled) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        this.started = false;
        // Always bind event so we cancel movement even if no action was taken
        window.addEventListener('mousemove', this.onMouseMove);
        window.addEventListener('mouseup', this.onMouseUp);
    }
    onTouchStart(event) {
        const { disabled } = this.props;
        if (disabled || event.touches.length !== 1) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        this.started = false;
        this.prevXPosition = event.touches[0].clientX;
        this.prevYPosition = event.touches[0].clientY;
        // Always bind event so we cancel movement even if no action was taken
        window.addEventListener('touchmove', this.onTouchMove);
        window.addEventListener('touchend', this.onTouchEnd);
    }
    render() {
        return Children.map(this.props.children, (child) => cloneElement(child, Object.assign(Object.assign({}, child.props), { onMouseDown: e => {
                this.onMouseDown(e);
                if (child.props.onMouseDown) {
                    child.props.onMouseDown(e);
                }
            }, onTouchStart: e => {
                this.onTouchStart(e);
                if (child.props.onTouchStart) {
                    child.props.onTouchStart(e);
                }
            } })));
    }
}
Move.defaultProps = {
    preventRightClick: true,
    disableText: true,
    threshold: 0,
    onMoveStart: () => undefined,
    onMove: () => undefined,
    onMoveEnd: () => undefined,
    onMoveCancel: () => undefined
};

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css = ".BrushHandle-module_handle__1sUPw {\n  fill: var(--color-background);\n  stroke: var(--color-primary); }\n\n.BrushHandle-module_dragging__MOc92 {\n  fill: var(--color-surface); }\n\n.BrushHandle-module_dot__1tWYP {\n  fill: var(--color-on-background); }\n\n.BrushHandle-module_line__Tqtk3 {\n  stroke: var(--color-primary); }\n";
var css$1 = {"handle":"BrushHandle-module_handle__1sUPw","dragging":"BrushHandle-module_dragging__MOc92","dot":"BrushHandle-module_dot__1tWYP","line":"BrushHandle-module_line__Tqtk3"};
styleInject(css);

class BrushHandle extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            isDragging: false
        };
    }
    onMoveStart() {
        this.setState({
            isDragging: true
        });
    }
    onMove(event) {
        this.props.onHandleDrag(event.x);
    }
    onMoveEnd() {
        this.setState({
            isDragging: false
        });
    }
    render() {
        const { height } = this.props;
        const { isDragging } = this.state;
        return (React.createElement(Move, { cursor: "ew-resize", onMoveStart: bind(this.onMoveStart, this), onMove: bind(this.onMove, this), onMoveEnd: bind(this.onMoveEnd, this) },
            React.createElement("g", null,
                React.createElement("line", { className: css$1.line, y1: "0", y2: height, x1: "5", x2: "5" }),
                React.createElement("rect", { className: classNames(css$1.handle, { [css$1.dragging]: isDragging }), height: height - 10, style: { cursor: 'ew-resize' }, width: 8, y: "5", y1: height - 5 }),
                React.createElement("g", { transform: `translate(-1, ${height / 2 - 10})`, style: { pointerEvents: 'none' } }, range(5).map(i => (React.createElement("circle", { cy: i * 5, cx: "5", r: ".5", key: i, className: css$1.dot })))))));
    }
}

var css$2 = ".BrushSlice-module_slice__25s30 {\n  fill: var(--color-primary); }\n\n.BrushSlice-module_unsliced__2a0pj {\n  fill: var(--color-background);\n  opacity: 0.5;\n  pointer-events: none; }\n";
var css$3 = {"slice":"BrushSlice-module_slice__25s30","unsliced":"BrushSlice-module_unsliced__2a0pj"};
styleInject(css$2);

class BrushSlice extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            isDragging: false
        };
    }
    onMoveStart() {
        const { start, end, width } = this.props;
        const hasNoSlice = start === 0 && end === width;
        if (!hasNoSlice) {
            this.setState({
                isDragging: true
            });
        }
    }
    onMove({ x }) {
        const { onBrushChange, width } = this.props;
        let { start, end } = this.props;
        start = start + x;
        end = end + x;
        if (start >= 0 && end <= width) {
            onBrushChange({
                start,
                end
            });
        }
    }
    onMoveEnd() {
        this.setState({
            isDragging: false
        });
    }
    onHandleDrag(direction, deltaX) {
        const { onBrushChange } = this.props;
        let { start, end } = this.props;
        start = direction === 'start' ? start + deltaX : start;
        end = direction !== 'start' ? end + deltaX : end;
        onBrushChange({
            start,
            end
        });
    }
    render() {
        const { height, start, end, width } = this.props;
        const { isDragging } = this.state;
        const sliceWidth = Math.max(end - start, 0);
        const endSliceWidth = Math.max(width - end, 0);
        const hasNoSlice = start === 0 && end === width;
        return (React.createElement(Fragment, null,
            React.createElement("rect", { className: css$3.unsliced, height: height, width: start }),
            React.createElement("rect", { transform: `translate(${end}, 0)`, className: css$3.unsliced, height: height, width: endSliceWidth }),
            React.createElement("g", { transform: `translate(${start}, 0)` },
                React.createElement(Move, { cursor: "grabbing", onMoveStart: bind(this.onMoveStart, this), onMove: bind(this.onMove, this), onMoveEnd: bind(this.onMoveEnd, this) },
                    React.createElement("rect", { className: css$3.slice, height: height, width: sliceWidth, style: {
                            cursor: isDragging ? 'grabbing' : 'grab',
                            opacity: hasNoSlice ? 0 : 0.1,
                            pointerEvents: !hasNoSlice ? 'initial' : 'none'
                        } })),
                React.createElement("g", { transform: `translate(-4, 0)` },
                    React.createElement(BrushHandle, { height: height, onHandleDrag: bind(this.onHandleDrag, this, 'start') })),
                React.createElement("g", { transform: `translate(${sliceWidth - 5}, 0)` },
                    React.createElement(BrushHandle, { height: height, onHandleDrag: bind(this.onHandleDrag, this, 'end') })))));
    }
}

class Brush extends PureComponent {
    constructor(props) {
        super(props);
        this.state = {
            isSlicing: false,
            isPanning: false,
            start: props.start || 0,
            end: props.end || props.width
        };
    }
    componentDidUpdate(prevProps) {
        // If no brush is defined and width updates, update the offset of the end handle.
        if (prevProps.width !== this.props.width &&
            this.state.end === prevProps.width) {
            this.setState({ end: this.props.width });
        }
        // Don't update if we are doing the slicing
        if (!this.state.isSlicing && !this.state.isPanning) {
            const { start, end } = this.props;
            const startUpdated = start !== prevProps.start && start !== this.state.start;
            const endUpdated = end !== prevProps.end && end !== this.state.end;
            if (startUpdated || endUpdated) {
                this.setState(Object.assign({}, this.ensurePositionInBounds(start, end)));
            }
        }
    }
    getStartEnd(event, state = this.state) {
        const { x } = this.getPositionsForPanEvent(event);
        let start;
        let end;
        if (x < state.initial) {
            start = x;
            end = state.initial;
        }
        else {
            start = state.initial;
            end = x;
        }
        return this.ensurePositionInBounds(start, end, state);
    }
    getPositionsForPanEvent(event) {
        const eventObj = {
            target: this.ref,
            clientX: event.clientX,
            clientY: event.clientY
        };
        return getPositionForTarget(eventObj);
    }
    ensurePositionInBounds(newStart, newEnd, state = this.state) {
        const { width } = this.props;
        let start = newStart;
        let end = newEnd;
        if (start === undefined || start <= 0) {
            start = 0;
        }
        if (end === undefined) {
            end = width;
        }
        if (start > end) {
            start = state.start;
        }
        if (end < start) {
            end = state.end;
        }
        if (end >= width) {
            end = width;
        }
        return { start, end };
    }
    onMoveStart(event) {
        const positions = this.getPositionsForPanEvent(event.nativeEvent);
        this.setState({
            isSlicing: true,
            initial: positions.x
        });
    }
    onMove(event) {
        this.setState(prev => {
            const { onBrushChange } = this.props;
            // Use setState callback so we can get the true previous value
            // rather than the bulk updated value react will trigger
            const { start, end } = this.getStartEnd(event.nativeEvent, prev);
            if (onBrushChange) {
                onBrushChange({
                    start,
                    end
                });
            }
            return {
                start,
                end
            };
        });
    }
    onMoveEnd() {
        this.setState({
            isSlicing: false
        });
    }
    onMoveCancel() {
        const val = {
            start: 0,
            end: this.props.width
        };
        this.setState(val);
        if (this.props.onBrushChange) {
            this.props.onBrushChange(val);
        }
    }
    onSliceChange(event) {
        const val = this.ensurePositionInBounds(event.start, event.end);
        this.setState(val);
        if (this.props.onBrushChange) {
            this.props.onBrushChange(val);
        }
    }
    render() {
        const { children, disabled, height, width } = this.props;
        const { isSlicing, start, end } = this.state;
        return (React.createElement(Move, { cursor: "crosshair", onMoveStart: bind(this.onMoveStart, this), onMove: bind(this.onMove, this), onMoveEnd: bind(this.onMoveEnd, this), onMoveCancel: bind(this.onMoveCancel, this) },
            React.createElement("g", { style: {
                    pointerEvents: isSlicing ? 'none' : 'auto',
                    cursor: disabled ? '' : 'crosshair'
                } },
                children,
                !disabled && (React.createElement(Fragment, null,
                    React.createElement("rect", { ref: ref => (this.ref = ref), height: height, width: width, opacity: 0 }),
                    start !== undefined && end !== undefined && (React.createElement(BrushSlice, { start: start, end: end, height: height, width: width, onBrushChange: bind(this.onSliceChange, this) })))))));
    }
}
Brush.defaultProps = {
    disabled: false,
    height: 0,
    width: 0,
    onBrushChange: () => undefined
};

class ChartBrush extends Component {
    getBrushOffset() {
        let start;
        let end;
        const { disabled, domain, scale } = this.props;
        if (!disabled && domain) {
            start = scale(domain[0]);
            end = scale(domain[1]);
        }
        return { start, end };
    }
    onBrushChange(event) {
        const { onBrushChange, scale, width } = this.props;
        if (onBrushChange) {
            let domain;
            if (event.start !== undefined &&
                event.end !== undefined &&
                (event.start !== 0 || event.end !== width)) {
                const start = scale.invert(event.start);
                const end = scale.invert(event.end);
                domain = [start, end];
            }
            onBrushChange({
                domain
            });
        }
    }
    render() {
        const _a = this.props, { scale, height, width, children } = _a, rest = __rest(_a, ["scale", "height", "width", "children"]);
        return (React.createElement(Brush, Object.assign({}, rest, this.getBrushOffset(), { height: height, width: width, onBrushChange: bind(this.onBrushChange, this) }), children));
    }
}
ChartBrush.defaultProps = {};

const ResizeInner = props => React.createElement(Fragment, null, props.children);
class ResizeContainer extends PureComponent {
    constructor(props) {
        super(props);
        if (this.shouldAutosize()) {
            this.SizeMe = withSize({
                monitorHeight: !props.height,
                monitorWidth: !props.width,
                refreshMode: 'debounce'
            })(ResizeInner);
        }
    }
    shouldAutosize() {
        return !this.props.height || !this.props.width;
    }
    render() {
        const { SizeMe } = this;
        const { children, onSize } = this.props;
        const shouldAutosize = this.shouldAutosize();
        return (React.createElement(Fragment, null,
            shouldAutosize && (React.createElement(SizeMe, { onSize: onSize },
                React.createElement("div", { style: { height: '100%', width: '100%' } }, children))),
            !shouldAutosize && children));
    }
}

let chartId = 0;
class ChartContainer extends Component {
    constructor(props) {
        super(props);
        const { margins, height, width } = props;
        this.state = Object.assign({ id: (chartId++).toString() }, getDimension({
            margins,
            height,
            width,
            yOffset: 0,
            xOffset: 0
        }));
    }
    componentDidUpdate(nextProps) {
        const { height, width } = this.props;
        if (width !== nextProps.width || height !== nextProps.height) {
            this.updateSize({
                height: nextProps.height,
                width: nextProps.width
            });
        }
    }
    onResize(event) {
        this.updateSize(Object.assign(Object.assign({}, event), { chartSized: true }));
    }
    updateAxes(orientation, event) {
        const propToken = orientation === 'horizontal' ? 'xAxisSized' : 'yAxisSized';
        this.updateSize({
            yOffset: event.height,
            xOffset: event.width,
            [propToken]: true
        });
    }
    updateSize(props) {
        this.setState(prev => (Object.assign({ chartSized: props.chartSized || prev.chartSized, 
            // TODO: @amcdnl refactor this be x0Offset/x1Offset/etc
            xAxisSized: props.xAxisSized || prev.xAxisSized, yAxisSized: props.yAxisSized || prev.yAxisSized }, getDimension({
            margins: this.props.margins,
            height: props.height || prev.height,
            width: props.width || prev.width,
            yOffset: props.yOffset || prev.yOffset,
            xOffset: props.xOffset || prev.xOffset
        }))));
    }
    getChartSized() {
        const { height, width, xAxisVisible, yAxisVisible } = this.props;
        const { xAxisSized, yAxisSized, chartSized } = this.state;
        if ((!height || !width) && !chartSized) {
            return false;
        }
        // TODO: @amcdnl refactor this to account for 0-2 axises on x/y
        if (xAxisVisible && !xAxisSized) {
            return false;
        }
        if (yAxisVisible && !yAxisSized) {
            return false;
        }
        return true;
    }
    render() {
        const { className, children, center, centerX, centerY, style } = this.props;
        const { xMargin, yMargin, width, height } = this.state;
        const id = this.props.id || this.state.id;
        const chartSized = this.getChartSized();
        const childProps = Object.assign(Object.assign({}, this.state), { chartSized,
            id, updateAxes: bind(this.updateAxes, this) });
        const translateX = center || centerX ? width / 2 : xMargin;
        const translateY = center || centerY ? height / 2 : yMargin;
        return (React.createElement(ResizeContainer, { onSize: bind(this.onResize, this), height: this.props.height, width: this.props.width }, height && width && (React.createElement("svg", { width: width, height: height, className: className, style: style },
            React.createElement("g", { transform: `translate(${translateX}, ${translateY})` }, children(childProps))))));
    }
}
ChartContainer.defaultProps = {
    margins: 10
};

function normalizeValue(value, maxBigInt) {
    if (bigInt.isInstance(value)) {
        if (maxBigInt.greater(1000000)) {
            const divideBy = maxBigInt.divide(1000000);
            return value.divide(divideBy).toJSNumber();
        }
        else {
            return value.toJSNumber();
        }
    }
    else {
        return value;
    }
}
function normalizeValueForFormatting(value) {
    if (bigInt.isInstance(value)) {
        return bigIntegerToLocaleString(value);
    }
    return value;
}
function getMaxBigIntegerForNested(series) {
    let maxBigInteger = bigInt.one;
    for (const group of series) {
        const maxBigIntegerForGroup = getMaxBigIntegerForShallow(group.data);
        if (maxBigIntegerForGroup.greater(maxBigInteger)) {
            maxBigInteger = maxBigIntegerForGroup;
        }
    }
    return maxBigInteger;
}
function getMaxBigIntegerForShallow(series) {
    let maxBigInteger = bigInt.one;
    for (const point of series) {
        if (bigInt.isInstance(point.data)) {
            const bigInteger = point.data;
            if (bigInteger.greater(maxBigInteger)) {
                maxBigInteger = bigInteger;
            }
        }
    }
    return maxBigInteger;
}

/**
 * Accepts a `ChartDataShape` and transforms it to a chart readable data shape.
 *
 * Example:
 *
 *   [{
 *    key: 'Threat Intel',
 *    data: [{ key:'2011', data: 25 }]
 *   }]
 *
 * will be transformed to:
 *
 *  [{
 *    key: 'Threat Intel',
 *    data: [
 *      key: 'Threat Intel',
 *      x: '2011',
 *      y: 25
 *    ]
 *  }]
 */
function buildNestedChartData(series, sort = false, direction = 'vertical') {
    let result = [];
    const maxBigInteger = getMaxBigIntegerForNested(series);
    const isVertical = direction === 'vertical';
    for (const point of series) {
        for (const nestedPoint of point.data) {
            const key = normalizeValueForFormatting(point.key);
            let idx = result.findIndex(r => {
                const left = r.key;
                if (left instanceof Date && key instanceof Date) {
                    return left.getTime() === key.getTime();
                }
                return left === key;
            });
            if (idx === -1) {
                result.push({
                    key,
                    metadata: point.metadata,
                    data: []
                });
                idx = result.length - 1;
            }
            const x = normalizeValue(isVertical ? nestedPoint.key : nestedPoint.data, maxBigInteger);
            const y = normalizeValue(isVertical ? nestedPoint.data : nestedPoint.key, maxBigInteger);
            result[idx].data.push({
                key,
                value: normalizeValueForFormatting(nestedPoint.data),
                metadata: nestedPoint.metadata,
                id: point.id,
                x,
                x0: isVertical ? x : 0,
                x1: x,
                y,
                y0: isVertical ? 0 : y,
                y1: y
            });
        }
    }
    // Sort the series data based on the median value
    if (sort) {
        result = result.sort((a, b) => {
            const aMax = median(a.data, (d) => d.y);
            const bMax = median(b.data, (d) => d.y);
            return aMax < bMax ? 1 : -1;
        });
    }
    return result;
}
function addToChartType(a, b) {
    if (bigInt.isInstance(a) && bigInt.isInstance(b)) {
        return a.add(b);
    }
    else if (a instanceof Date && typeof b === 'number') {
        return new Date(a.valueOf() + b);
    }
    else if (typeof a === 'number' && typeof b === 'number') {
        return a + b;
    }
    else {
        throw new Error('Invalid types to addToChartTypes');
    }
}
/**
 * Accepts a shallow shape and normalizes it to a chart readable format.
 */
function buildShallowChartData(series, direction = 'vertical', binSize = undefined) {
    const result = [];
    const maxBigInteger = getMaxBigIntegerForShallow(series);
    const isVertical = direction === 'vertical';
    for (const point of series) {
        const isTuple = Array.isArray(point.data);
        let k1 = point.key;
        if (binSize) {
            k1 = addToChartType(point.key, binSize);
        }
        const props = {
            k0: normalizeValue(point.key, maxBigInteger),
            k1: normalizeValue(k1, maxBigInteger),
            v0: normalizeValue(isTuple ? point.data[0] : 0, maxBigInteger),
            v1: normalizeValue(isTuple ? point.data[1] : point.data, maxBigInteger)
        };
        const xProp = isVertical ? 'k' : 'v';
        const yProp = isVertical ? 'v' : 'k';
        result.push({
            key: normalizeValueForFormatting(props.k0),
            value: normalizeValueForFormatting(props.v1),
            metadata: point.metadata,
            id: point.id,
            x: props[`${xProp}1`],
            x0: props[`${xProp}0`],
            x1: props[`${xProp}1`],
            y: props[`${yProp}1`],
            y0: props[`${yProp}0`],
            y1: props[`${yProp}1`]
        });
    }
    return result;
}

/**
 * Build a histogram given data set.
 */
function buildBins(xScale, thresholds, data) {
    const layout = histogram()
        .value((d) => d.x)
        .domain(xScale.domain())
        .thresholds(xScale.ticks(thresholds));
    const bins = layout(data);
    return bins.map(bin => ({
        x0: bin.x0,
        x1: bin.x1,
        y: bin.length,
        y0: 0,
        y1: bin.length
    }));
}

/**
 * Given a dataset like:
 *
 *   [{
 *    key: 'Threat Intel',
 *    data: [{ key:'2011', data: 25 }]
 *   }]
 *
 * it will transform it to:
 *
 *  [
 *    { x: 'Theat Intel', '2011': 25 }
 *  ]
 */
function transformDataToStack(data) {
    const result = [];
    const maxBigInteger = getMaxBigIntegerForNested(data);
    for (const category of data) {
        for (const value of category.data) {
            let idx = result.findIndex(r => {
                if (r.x instanceof Date && category.key instanceof Date) {
                    return r.x.getTime() === category.key.getTime();
                }
                return r.x === category.key;
            });
            if (idx === -1) {
                result.push({
                    metadata: category.metadata,
                    x: category.key,
                    formattedValues: {}
                });
                idx = result.length - 1;
            }
            result[idx][value.key] = normalizeValue(value.data, maxBigInteger);
            result[idx].formattedValues[value.key] = normalizeValueForFormatting(value.data);
        }
    }
    return result;
}
/**
 * Translates the stack data to a chart standard dataset.
 */
function transformStackToData(stackData, direction = 'vertical') {
    const result = [];
    const isVertical = direction === 'vertical';
    // Transform the data from the d3 stack format to our internal format
    for (const category of stackData) {
        for (const point of category) {
            const key = point.data.x;
            let idx = result.findIndex(r => {
                if (r.key instanceof Date && key instanceof Date) {
                    return r.key.getTime() === key.getTime();
                }
                return r.key === key;
            });
            if (idx === -1) {
                result.push({
                    key,
                    data: []
                });
                idx = result.length - 1;
            }
            const categoryKey = category.key;
            const y = point.data[categoryKey];
            const [y0, y1] = point;
            result[idx].data.push({
                metadata: point.data.metadata,
                key,
                x: isVertical ? categoryKey : y1,
                x0: isVertical ? categoryKey : y0,
                x1: isVertical ? categoryKey : y1,
                y: isVertical ? y : categoryKey,
                y0: isVertical ? y0 : categoryKey,
                y1: isVertical ? y1 : categoryKey,
                value: point.data.formattedValues[categoryKey]
            });
        }
    }
    return result;
}
/**
 * Builds a stack dataset from the standard data format.
 */
function buildBarStackData(data, offset = 'default', direction = 'vertical') {
    const keys = uniqueBy(data, d => d.data, d => d.key);
    const stackData = transformDataToStack(data);
    let stackFn = stack();
    if (offset === 'expand') {
        stackFn = stackFn.offset(stackOffsetExpand);
    }
    else if (offset === 'diverging') {
        stackFn = stackFn.offset(stackOffsetDiverging);
    }
    const result = stackFn.keys(keys)(stackData);
    return transformStackToData(result, direction);
}

/**
 * Builds a stack dataset from the standard data format.
 */
function buildMarimekkoData(data) {
    const result = buildBarStackData(data, 'expand');
    const sums = {};
    // Calculate the sum for each series and the total sum
    let totalSum = 0;
    for (const series of result) {
        const sum = series.data.reduce((acc, cur) => acc + cur.y, 0);
        sums[series.key] = sum;
        totalSum += sum;
    }
    // Calculate the x0/x1 for each series
    let prev = 0;
    for (const series of result) {
        const x0 = prev;
        const x1 = prev + sums[series.key] / totalSum;
        prev = x1;
        for (const point of series.data) {
            point.x0 = x0;
            point.x1 = x1;
        }
    }
    return result;
}

/**
 * Given a dataset like:
 *
 *   [{
 *    key: 'Threat Intel',
 *    data: [{ key:'2011', data: 25 }]
 *   }]
 *
 * it will transform it to:
 *
 *  [
 *    { x: '2011', 'Theat Intel': 25 }
 *  ]
 */
function transformDataToStack$1(data) {
    const result = [];
    const maxBigInteger = getMaxBigIntegerForNested(data);
    for (const category of data) {
        for (const value of category.data) {
            let idx = result.findIndex(r => {
                if (r.x instanceof Date && value.key instanceof Date) {
                    return r.x.getTime() === value.key.getTime();
                }
                return r.x === value.key;
            });
            if (idx === -1) {
                result.push({
                    x: value.key,
                    formattedValues: {}
                });
                idx = result.length - 1;
            }
            result[idx][category.key] = normalizeValue(value.data, maxBigInteger);
            result[idx].formattedValues[category.key] = normalizeValueForFormatting(value.data);
        }
    }
    return result;
}
/**
 * Translates the stack data to a chart standard dataset.
 */
function transformStackToData$1(stackData) {
    const result = [];
    for (const category of stackData) {
        const series = [];
        for (const point of category) {
            const [y0, y1] = point;
            const x = point.data.x;
            series.push({
                key: category.key,
                x,
                x0: x,
                x1: x,
                y: y1 - y0,
                y0,
                y1,
                value: point.data.formattedValues[category.key]
            });
        }
        result.push({
            key: category.key,
            data: series
        });
    }
    return result;
}
/**
 * Builds a stack dataset from the standard data format.
 */
function buildStackData(data, normalized = false) {
    const keys = uniqueBy(data, d => d.key);
    const stackData = transformDataToStack$1(data);
    const stackFn = !normalized ? stack() : stack().offset(stackOffsetExpand);
    const result = stackFn.keys(keys)(stackData);
    return transformStackToData$1(result);
}

const buildWaterfall = (series, direction = 'vertical', binSize = undefined) => {
    const data = buildShallowChartData(series, direction, binSize);
    const isVertical = direction === 'vertical';
    const v = isVertical ? 'y' : 'x';
    let cumulative = 0;
    for (const point of data) {
        point[`${v}0`] = cumulative;
        cumulative += point[v];
        point[`${v}1`] = cumulative;
        point[v] = cumulative;
    }
    return data;
};

class Pan extends Component {
    constructor() {
        super(...arguments);
        this.prevXPosition = 0;
        this.prevYPosition = 0;
        this.started = false;
        this.deltaX = 0;
        this.deltaY = 0;
        this.childRef = createRef();
        this.onMouseDown = (event) => {
            // Stop at disabled
            if (this.props.disabled) {
                return;
            }
            // Ignore right click
            if (event.which === 3) {
                return;
            }
            // If global panning is turned off, it will only pan on the container
            if (!this.props.globalPanning &&
                event.target &&
                !event.target.classList.contains('pan-container')) {
                return;
            }
            event.preventDefault();
            event.stopPropagation();
            toggleTextSelection(false);
            this.started = false;
            // Always bind event so we cancel movement even if no action was taken
            window.addEventListener('mousemove', this.onMouseMove);
            window.addEventListener('mouseup', this.onMouseUp);
        };
        this.onMouseMove = (event) => {
            event.preventDefault();
            event.stopPropagation();
            this.deltaX = this.deltaX + event.movementX;
            this.deltaY = this.deltaY + event.movementY;
            if (this.checkThreshold()) {
                if (this.props.cursor) {
                    document.body.style['cursor'] = this.props.cursor;
                }
                this.deltaX = 0;
                this.deltaY = 0;
                this.started = true;
                this.onPanStart(event, 'mouse');
            }
            else {
                this.pan(event.movementX, event.movementY, event, 'mouse');
            }
        };
        this.onMouseUp = (event) => {
            event.preventDefault();
            event.stopPropagation();
            this.disposeHandlers();
            toggleTextSelection(true);
            if (this.started) {
                this.onPanEnd(event, 'mouse');
            }
            else {
                this.props.onPanCancel({
                    nativeEvent: event,
                    source: 'mouse'
                });
            }
        };
        this.onTouchStart = (event) => {
            // Stop at disabled
            if (this.props.disabled) {
                return;
            }
            // Reqquire more than one touch
            if (event.touches.length !== 1) {
                return;
            }
            event.preventDefault();
            event.stopPropagation();
            toggleTextSelection(false);
            this.started = false;
            this.prevXPosition = event.touches[0].clientX;
            this.prevYPosition = event.touches[0].clientY;
            // Always bind event so we cancel movement even if no action was taken
            window.addEventListener('touchmove', this.onTouchMove);
            window.addEventListener('touchend', this.onTouchEnd);
        };
        this.onTouchMove = (event) => {
            event.preventDefault();
            event.stopPropagation();
            // Calculate delta from previous position and current
            const x = event.touches[0].clientX;
            const y = event.touches[0].clientY;
            const deltaX = x - this.prevXPosition;
            const deltaY = y - this.prevYPosition;
            this.deltaX = this.deltaX + deltaX;
            this.deltaY = this.deltaY + deltaY;
            if (this.checkThreshold()) {
                this.deltaX = 0;
                this.deltaY = 0;
                this.started = true;
                this.onPanStart(event, 'touch');
            }
            else {
                const contrained = this.pan(deltaX, deltaY, event, 'touch');
                if (!contrained) {
                    this.prevXPosition = x;
                    this.prevYPosition = y;
                }
            }
        };
        this.onTouchEnd = (event) => {
            event.preventDefault();
            event.stopPropagation();
            this.disposeHandlers();
            toggleTextSelection(true);
            if (this.started) {
                this.onPanEnd(event, 'touch');
            }
            else {
                this.props.onPanCancel({
                    nativeEvent: event,
                    source: 'touch'
                });
            }
        };
    }
    componentDidMount() {
        if (this.childRef.current) {
            this.childRef.current.addEventListener('mousedown', this.onMouseDown, {
                passive: false
            });
            this.childRef.current.addEventListener('touchstart', this.onTouchStart, {
                passive: false
            });
        }
    }
    componentWillUnmount() {
        this.disposeHandlers();
        if (this.childRef.current) {
            this.childRef.current.removeEventListener('mousedown', this.onMouseDown);
            this.childRef.current.removeEventListener('touchstart', this.onTouchStart);
        }
    }
    disposeHandlers() {
        window.removeEventListener('mousemove', this.onMouseMove);
        window.removeEventListener('mouseup', this.onMouseUp);
        window.removeEventListener('touchmove', this.onTouchMove);
        window.removeEventListener('touchend', this.onTouchEnd);
        // Reset cursor on body back to original
        document.body.style['cursor'] = 'inherit';
        toggleTextSelection(true);
    }
    checkThreshold() {
        const { threshold } = this.props;
        return (!this.started &&
            (Math.abs(this.deltaX) > threshold || Math.abs(this.deltaY) > threshold));
    }
    onPanStart(nativeEvent, source) {
        this.props.onPanStart({
            nativeEvent,
            source
        });
    }
    onPanMove(x, y, source, nativeEvent) {
        this.props.onPanMove({
            source,
            nativeEvent,
            x,
            y
        });
    }
    onPanEnd(nativeEvent, source) {
        const { onPanEnd } = this.props;
        onPanEnd({
            nativeEvent,
            source
        });
    }
    pan(x, y, nativeEvent, source) {
        const { scale, constrain, width, height, matrix } = this.props;
        const newMatrix = smoothMatrix(transform(matrix, translate$1(x / scale, y / scale)), 100);
        const shouldConstrain = constrain && constrainMatrix(height, width, newMatrix);
        if (!shouldConstrain) {
            this.onPanMove(newMatrix.e, newMatrix.f, source, nativeEvent);
        }
        return shouldConstrain;
    }
    render() {
        return React.createElement("g", { ref: this.childRef }, this.props.children);
    }
}
Pan.defaultProps = {
    x: 0,
    y: 0,
    disabled: false,
    scale: 1,
    threshold: 10,
    globalPanning: true,
    onPanStart: () => undefined,
    onPanMove: () => undefined,
    onPanEnd: () => undefined,
    onPanCancel: () => undefined
};

/**
 * Gets the position between a given set of points.
 */
const getMidpoint = (pointA, pointB) => ({
    x: (pointA.x + pointB.x) / 2,
    y: (pointA.y + pointB.y) / 2
});
/**
 * Gets the distance between a given set of points.
 */
const getDistanceBetweenPoints = (pointA, pointB) => Math.sqrt(Math.pow(pointB.y - pointA.y, 2) + Math.pow(pointB.x - pointA.x, 2));
/**
 * Get touch points.
 */
function getTouchPoints(event, node) {
    const { left, top } = node.getBoundingClientRect();
    const [pointA, pointB] = [...event.touches].map(touch => ({
        x: touch.clientX - Math.round(left),
        y: touch.clientY - Math.round(top)
    }));
    const distance = getDistanceBetweenPoints(pointA, pointB);
    const midpoint = getMidpoint(pointA, pointB);
    return {
        pointA,
        pointB,
        distance,
        midpoint
    };
}

class Zoom extends Component {
    constructor() {
        super(...arguments);
        this.childRef = createRef();
        this.onMouseWheel = event => {
            const { disableMouseWheel, requireZoomModifier, matrix, onZoomEnd } = this.props;
            if (disableMouseWheel) {
                return false;
            }
            const hasModifier = event.metaKey || event.ctrlKey;
            if (requireZoomModifier && !hasModifier) {
                return false;
            }
            event.preventDefault();
            event.stopPropagation();
            const point = getPointFromMatrix(event, matrix);
            if (point) {
                const { x, y } = point;
                const step = this.getStep(event.deltaY);
                this.scale(x, y, step, event);
                // Do small timeout to 'guess' when its done zooming
                clearTimeout(this.timeout);
                this.timeout = setTimeout(() => onZoomEnd(), 500);
            }
        };
        this.onTouchStart = (event) => {
            if (event.touches.length === 2) {
                event.preventDefault();
                event.stopPropagation();
                toggleTextSelection(false);
                this.firstTouch = getTouchPoints(event, this.childRef.current);
                this.lastDistance = this.firstTouch.distance;
                window.addEventListener('touchmove', this.onTouchMove);
                window.addEventListener('touchend', this.onTouchEnd);
            }
        };
        this.onTouchMove = (event) => {
            if (event.touches.length === 2) {
                event.preventDefault();
                event.stopPropagation();
                const { distance } = getTouchPoints(event, this.childRef.current);
                const distanceFactor = distance / this.lastDistance;
                const point = applyToPoint(inverse(this.props.matrix), {
                    x: this.firstTouch.midpoint.x,
                    y: this.firstTouch.midpoint.y
                });
                if (point.x && point.y) {
                    const outside = this.scale(point.x, point.y, distanceFactor, event);
                    if (!outside) {
                        this.lastDistance = distance;
                    }
                }
            }
        };
        this.onTouchEnd = (event) => {
            event.preventDefault();
            event.stopPropagation();
            window.removeEventListener('touchmove', this.onTouchMove);
            window.removeEventListener('touchend', this.onTouchEnd);
            toggleTextSelection(true);
            this.props.onZoomEnd();
        };
    }
    componentDidMount() {
        const { disabled, disableMouseWheel } = this.props;
        const ref = this.childRef.current;
        if (!disabled && ref) {
            if (!disableMouseWheel) {
                ref.addEventListener('mousewheel', this.onMouseWheel, {
                    passive: false
                });
            }
            ref.addEventListener('touchstart', this.onTouchStart, { passive: false });
        }
    }
    componentWillUnmount() {
        window.removeEventListener('touchmove', this.onTouchMove);
        window.removeEventListener('touchend', this.onTouchEnd);
        cancelAnimationFrame(this.rqf);
        clearTimeout(this.timeout);
        const ref = this.childRef.current;
        if (ref) {
            ref.removeEventListener('mousewheel', this.onMouseWheel);
            ref.removeEventListener('touchstart', this.onTouchStart);
        }
        toggleTextSelection(true);
    }
    getStep(delta) {
        const { scaleFactor } = this.props;
        return -delta > 0 ? scaleFactor + 1 : 1 - scaleFactor;
    }
    scale(x, y, step, nativeEvent) {
        const { minZoom, maxZoom, onZoom, matrix } = this.props;
        const outside = isZoomLevelGoingOutOfBounds({
            d: matrix.a,
            scaleFactorMin: minZoom,
            scaleFactorMax: maxZoom
        }, step);
        if (!outside) {
            const newMatrix = smoothMatrix(transform(matrix, translate$1(x, y), scale(step, step), translate$1(-x, -y)), 100);
            this.rqf = requestAnimationFrame(() => {
                onZoom({
                    scale: newMatrix.a,
                    x: newMatrix.e,
                    y: newMatrix.f,
                    nativeEvent
                });
            });
        }
        return outside;
    }
    render() {
        const { style, children } = this.props;
        return (React.createElement("g", { ref: this.childRef, style: style }, children));
    }
}
Zoom.defaultProps = {
    x: 0,
    y: 0,
    scale: 1,
    scaleFactor: 0.1,
    minZoom: 1,
    maxZoom: 10
};

var css$4 = ".DiscreteLegend-module_container__2mEDZ {\n  display: -webkit-box;\n  display: flex;\n  overflow: auto; }\n  .DiscreteLegend-module_container__2mEDZ.DiscreteLegend-module_horizontal__1X-xR {\n    -webkit-box-align: center;\n            align-items: center;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n            flex-direction: row; }\n  .DiscreteLegend-module_container__2mEDZ.DiscreteLegend-module_vertical__2VWFB {\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n            flex-direction: column; }\n";
var css$5 = {"container":"DiscreteLegend-module_container__2mEDZ","horizontal":"DiscreteLegend-module_horizontal__1X-xR","vertical":"DiscreteLegend-module_vertical__2VWFB"};
styleInject(css$4);

class DiscreteLegend extends Component {
    render() {
        const { entries, orientation, style } = this.props;
        const className = classNames(css$5.container, this.props.className, {
            [css$5.horizontal]: orientation === 'horizontal',
            [css$5.vertical]: orientation === 'vertical'
        });
        return (React.createElement("div", { className: className, style: style }, entries.map((entry, index) => (React.createElement(CloneElement, { element: entry, key: `dle-${index}` })))));
    }
}
DiscreteLegend.defaultProps = {
    orientation: 'vertical'
};

var css$6 = ".DiscreteLegendEntry-module_entry__2t_fB {\n  display: -webkit-box;\n  display: flex;\n  color: var(--color-on-primary);\n  padding: 8px;\n  will-change: transparency;\n  -webkit-transition: opacity 150ms ease-in;\n  transition: opacity 150ms ease-in; }\n  .DiscreteLegendEntry-module_entry__2t_fB.DiscreteLegendEntry-module_vertical__hlqTw {\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n            flex-direction: column;\n    text-align: center; }\n    .DiscreteLegendEntry-module_entry__2t_fB.DiscreteLegendEntry-module_vertical__hlqTw:first-child {\n      padding-top: 0; }\n    .DiscreteLegendEntry-module_entry__2t_fB.DiscreteLegendEntry-module_vertical__hlqTw:last-child {\n      padding-bottom: 0; }\n    .DiscreteLegendEntry-module_entry__2t_fB.DiscreteLegendEntry-module_vertical__hlqTw svg {\n      display: block;\n      margin: 0 auto; }\n  .DiscreteLegendEntry-module_entry__2t_fB.DiscreteLegendEntry-module_horizontal__22RL3 {\n    -webkit-box-align: center;\n            align-items: center;\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: normal;\n            flex-direction: row; }\n    .DiscreteLegendEntry-module_entry__2t_fB.DiscreteLegendEntry-module_horizontal__22RL3:first-child {\n      padding-left: 0; }\n    .DiscreteLegendEntry-module_entry__2t_fB.DiscreteLegendEntry-module_horizontal__22RL3:last-child {\n      padding-right: 0; }\n    .DiscreteLegendEntry-module_entry__2t_fB.DiscreteLegendEntry-module_horizontal__22RL3 .DiscreteLegendEntry-module_label__1eXDb {\n      margin-left: 8px; }\n  .DiscreteLegendEntry-module_entry__2t_fB .DiscreteLegendEntry-module_label__1eXDb {\n    font-size: 12px; }\n  .DiscreteLegendEntry-module_entry__2t_fB svg {\n    width: 15px;\n    height: 15px; }\n";
var css$7 = {"entry":"DiscreteLegendEntry-module_entry__2t_fB","vertical":"DiscreteLegendEntry-module_vertical__hlqTw","horizontal":"DiscreteLegendEntry-module_horizontal__22RL3","label":"DiscreteLegendEntry-module_label__1eXDb"};
styleInject(css$6);

var css$8 = ".DiscreteLegendSymbol-module_symbol__jSdtc {\n  width: 15px;\n  height: 3px; }\n";
var css$9 = {"symbol":"DiscreteLegendSymbol-module_symbol__jSdtc"};
styleInject(css$8);

class DiscreteLegendSymbol extends PureComponent {
    render() {
        const { className, color } = this.props;
        return (React.createElement("div", { className: classNames(css$9.symbol, className), style: { background: color } }));
    }
}
DiscreteLegendSymbol.defaultProps = {};

class DiscreteLegendEntry extends Component {
    render() {
        const { label, symbol, onMouseEnter, onMouseLeave, title, color, style, onClick, orientation } = this.props;
        const className = classNames(css$7.entry, this.props.className, {
            [css$7.vertical]: orientation === 'vertical',
            [css$7.horizontal]: orientation === 'horizontal'
        });
        return (React.createElement("div", { title: title, className: className, onClick: onClick, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, style: style },
            React.createElement(CloneElement, { element: symbol, color: color }),
            React.createElement("span", { className: css$7.label }, label)));
    }
}
DiscreteLegendEntry.defaultProps = {
    symbol: React.createElement(DiscreteLegendSymbol, null),
    orientation: 'horizontal',
    onMouseEnter: () => undefined,
    onMouseLeave: () => undefined,
    onClick: () => undefined
};

var css$a = ".SequentialLegend-module_container__3zYTi {\n  display: -webkit-box;\n  display: flex;\n  height: 100%; }\n  .SequentialLegend-module_container__3zYTi.SequentialLegend-module_vertical__1GIoN {\n    -webkit-box-orient: vertical;\n    -webkit-box-direction: normal;\n            flex-direction: column;\n    max-width: 55px; }\n    .SequentialLegend-module_container__3zYTi.SequentialLegend-module_vertical__1GIoN .SequentialLegend-module_start__2Ed_Q,\n    .SequentialLegend-module_container__3zYTi.SequentialLegend-module_vertical__1GIoN .SequentialLegend-module_end__1vA4W {\n      text-align: center;\n      padding: 5px 0;\n      width: 100%; }\n    .SequentialLegend-module_container__3zYTi.SequentialLegend-module_vertical__1GIoN .SequentialLegend-module_gradient__ebuYY {\n      width: 25px;\n      margin: 0 auto; }\n  .SequentialLegend-module_container__3zYTi.SequentialLegend-module_horizontal__ljDoI {\n    -webkit-box-orient: horizontal;\n    -webkit-box-direction: reverse;\n            flex-direction: row-reverse; }\n    .SequentialLegend-module_container__3zYTi.SequentialLegend-module_horizontal__ljDoI .SequentialLegend-module_start__2Ed_Q,\n    .SequentialLegend-module_container__3zYTi.SequentialLegend-module_horizontal__ljDoI .SequentialLegend-module_end__1vA4W {\n      max-width: 20%; }\n    .SequentialLegend-module_container__3zYTi.SequentialLegend-module_horizontal__ljDoI .SequentialLegend-module_start__2Ed_Q {\n      text-align: right;\n      padding-left: 5px; }\n    .SequentialLegend-module_container__3zYTi.SequentialLegend-module_horizontal__ljDoI .SequentialLegend-module_end__1vA4W {\n      text-align: left;\n      padding-right: 5px; }\n  .SequentialLegend-module_container__3zYTi .SequentialLegend-module_gradient__ebuYY {\n    -webkit-box-flex: 1;\n            flex: 1;\n    width: 100%;\n    border-radius: 2px; }\n  .SequentialLegend-module_container__3zYTi .SequentialLegend-module_start__2Ed_Q,\n  .SequentialLegend-module_container__3zYTi .SequentialLegend-module_end__1vA4W {\n    color: var(--color-on-primary);\n    font-size: 12px;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis; }\n";
var css$b = {"container":"SequentialLegend-module_container__3zYTi","vertical":"SequentialLegend-module_vertical__1GIoN","start":"SequentialLegend-module_start__2Ed_Q","end":"SequentialLegend-module_end__1vA4W","gradient":"SequentialLegend-module_gradient__ebuYY","horizontal":"SequentialLegend-module_horizontal__ljDoI"};
styleInject(css$a);

class SequentialLegend extends PureComponent {
    render() {
        const { orientation, className, style, colorScheme, data } = this.props;
        // Generate the color gradient
        const color = chroma
            .scale(colorScheme)
            .colors(10)
            .reverse()
            .map((c, i) => `${c} ${i * 10}%`)
            .join(',');
        // Get the extent from the data passed
        const [end, start] = extent$1(uniqueBy(data, d => d.data, d => d.data));
        // Get direction
        const gradientDir = orientation === 'vertical' ? '' : 'to left,';
        return (React.createElement("div", { style: style, className: classNames(css$b.container, className, {
                [css$b.vertical]: orientation === 'vertical',
                [css$b.horizontal]: orientation === 'horizontal'
            }) },
            React.createElement("div", { className: css$b.start }, formatValue(start)),
            React.createElement("div", { className: css$b.gradient, style: {
                    background: `linear-gradient(${gradientDir}${color})`
                } }),
            React.createElement("div", { className: css$b.end }, formatValue(end))));
    }
}
SequentialLegend.defaultProps = {
    colorScheme: ['rgba(28, 107, 86, 0.5)', '#2da283'],
    orientation: 'vertical'
};

var css$c = ".Gridline-module_gridLine__3cVfZ {\n  stroke-dasharray: 2 5;\n  shape-rendering: crispEdges;\n  pointer-events: none; }\n";
var css$d = {"gridLine":"Gridline-module_gridLine__3cVfZ"};
styleInject(css$c);

class Gridline extends PureComponent {
    getCoords() {
        const { direction, data, height, width, scale, strokeWidth, strokeColor, strokeDasharray } = this.props;
        const pos = scale(data);
        if (direction === 'x') {
            return {
                x1: pos,
                x2: pos,
                y1: 0,
                y2: height,
                fill: 'none',
                stroke: strokeColor,
                strokeDasharray,
                strokeWidth
            };
        }
        else {
            return {
                y1: pos,
                y2: pos,
                x1: 0,
                x2: width,
                fill: 'none',
                stroke: strokeColor,
                strokeDasharray,
                strokeWidth
            };
        }
    }
    render() {
        const coords = this.getCoords();
        return React.createElement("line", Object.assign({ className: css$d.gridLine }, coords));
    }
}
Gridline.defaultProps = {
    strokeWidth: 1,
    direction: 'all',
    strokeColor: 'rgba(153, 153, 153, 0.5)'
};

class GridlineSeries extends Component {
    getGridlines() {
        const { yScale, xScale, yAxis, xAxis, height, width } = this.props;
        return {
            yAxisGrid: getTicks(yScale, yAxis.tickSeries.props.tickValues, yAxis.type, getMaxTicks(yAxis.tickSeries.props.tickSize, height), yAxis.tickSeries.props.interval),
            xAxisGrid: getTicks(xScale, xAxis.tickSeries.props.tickValues, xAxis.type, getMaxTicks(xAxis.tickSeries.props.tickSize, width), xAxis.tickSeries.props.interval)
        };
    }
    renderSeries(yAxisGrid, xAxisGrid, element, type) {
        const { xScale, yScale } = this.props;
        return (React.createElement(Fragment, null,
            this.shouldRenderY(element.props.direction) &&
                this.renderGroup(element, yAxisGrid, yScale, 'y', type),
            this.shouldRenderX(element.props.direction) &&
                this.renderGroup(element, xAxisGrid, xScale, 'x', type)));
    }
    shouldRenderY(direction) {
        return direction === 'all' || direction === 'y';
    }
    shouldRenderX(direction) {
        return direction === 'all' || direction === 'x';
    }
    getSkipIndex(direction) {
        const { yAxis, xAxis } = this.props;
        if ((direction === 'x' &&
            yAxis.axisLine !== null &&
            yAxis.position === 'start') ||
            (direction === 'y' && xAxis.axisLine !== null && xAxis.position === 'end')) {
            return 0;
        }
        return null;
    }
    renderGroup(element, grid, scale, direction, type) {
        const { height, width } = this.props;
        const skipIdx = this.getSkipIndex(direction);
        return grid.map((point, index) => (React.createElement(Fragment, { key: `${type}-${direction}-${index}` }, index !== skipIdx && (React.createElement(CloneElement, { element: element, index: index, scale: scale, data: point, height: height, width: width, direction: direction })))));
    }
    render() {
        const { line, stripe } = this.props;
        const { yAxisGrid, xAxisGrid } = this.getGridlines();
        return (React.createElement("g", { style: { pointerEvents: 'none' } },
            line && this.renderSeries(yAxisGrid, xAxisGrid, line, 'line'),
            stripe && this.renderSeries(yAxisGrid, xAxisGrid, stripe, 'stripe')));
    }
}
GridlineSeries.defaultProps = {
    line: React.createElement(Gridline, null),
    stripe: null
};

var css$e = ".GridStripe-module_gridStripe__1UlRd {\n  pointer-events: none; }\n";
var css$f = {"gridStripe":"GridStripe-module_gridStripe__1UlRd"};
styleInject(css$e);

class GridStripe extends PureComponent {
    getCoords() {
        const { position, data, height, width, scale, fill, index } = this.props;
        const pos = scale(data);
        const stripeFill = index % 2 ? 'none' : fill;
        const dim = scale.bandwidth();
        if (position === 'vertical') {
            return {
                y: 0,
                x: pos,
                height: height,
                width: dim,
                fill: stripeFill
            };
        }
        else {
            return {
                y: pos,
                x: 0,
                height: dim,
                width,
                fill: stripeFill
            };
        }
    }
    render() {
        const coords = this.getCoords();
        return React.createElement("rect", Object.assign({ className: css$f.gridStripe }, coords));
    }
}
GridStripe.defaultProps = {
    fill: '#2a3138'
};

var css$g = ".MarkLine-module_markLine__Uilm3 {\n  pointer-events: none;\n  stroke-dasharray: 4, 4;\n  stroke-linecap: round; }\n";
var css$h = {"markLine":"MarkLine-module_markLine__Uilm3"};
styleInject(css$g);

class MarkLine extends PureComponent {
    render() {
        const { pointX, height, strokeColor, strokeWidth } = this.props;
        return (React.createElement("line", { stroke: strokeColor, strokeWidth: strokeWidth, y1: "0", vectorEffect: "non-scaling-stroke", y2: height, x1: pointX, x2: pointX, className: css$h.markLine }));
    }
}
MarkLine.defaultProps = {
    strokeWidth: 1,
    strokeColor: '#eee'
};

class GradientStop extends PureComponent {
    render() {
        const { offset, stopOpacity, color } = this.props;
        return React.createElement("stop", { offset: offset, stopOpacity: stopOpacity, stopColor: color });
    }
}
GradientStop.defaultProps = {
    stopOpacity: 1
};

class Gradient extends Component {
    getDirection() {
        if (this.props.direction === 'vertical') {
            return {
                x1: '10%',
                x2: '10%',
                y1: '100%',
                y2: '0%'
            };
        }
        else {
            return {
                y1: '0%',
                y2: '0%',
                x1: '0%',
                x2: '100%'
            };
        }
    }
    render() {
        const { id, stops, color } = this.props;
        const direction = this.getDirection();
        return (React.createElement("linearGradient", Object.assign({ spreadMethod: "pad", id: id }, direction), stops.map((stop, index) => (React.createElement(CloneElement, { element: stop, key: `gradient-${index}`, color: stop.props.color || color })))));
    }
}
Gradient.defaultProps = {
    direction: 'vertical',
    stops: [
        React.createElement(GradientStop, { offset: "0%", stopOpacity: 0.3, key: "start" }),
        React.createElement(GradientStop, { offset: "80%", stopOpacity: 1, key: "stop" })
    ]
};

class RadialGradient extends Component {
    render() {
        const { id, stops, color, radius } = this.props;
        return (React.createElement("radialGradient", { id: id, cx: 0, cy: 0, r: radius, gradientUnits: "userSpaceOnUse" }, stops.map((stop, index) => (React.createElement(CloneElement, { element: stop, key: `gradient-${index}`, color: color })))));
    }
}
RadialGradient.defaultProps = {
    radius: '30%',
    stops: [
        React.createElement(GradientStop, { offset: "0%", stopOpacity: 0.2, key: "start" }),
        React.createElement(GradientStop, { offset: "80%", stopOpacity: 0.7, key: "stop" })
    ]
};

class Mask extends PureComponent {
    render() {
        const { id, fill } = this.props;
        return (React.createElement("mask", { id: id },
            React.createElement("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: fill })));
    }
}

class Stripes extends PureComponent {
    render() {
        const { id, fill } = this.props;
        return (React.createElement("pattern", { id: id, width: "4", height: "4", patternUnits: "userSpaceOnUse", patternTransform: "rotate(45)" },
            React.createElement("rect", { className: "area-stripe", width: "1", height: "4", fill: fill })));
    }
}
Stripes.defaultProps = {};

var css$i = ".Tooltip-module_tooltip__omIxd {\n  background: var(--color-layer-transparent);\n  border-radius: 5px;\n  color: var(--color-on-background);\n  pointer-events: none;\n  padding: 7px;\n  white-space: nowrap;\n  text-align: center;\n  will-change: transform, opacity; }\n";
var css$j = {"tooltip":"Tooltip-module_tooltip__omIxd"};
styleInject(css$i);

const tooltips = [];
const Tooltip = (_a) => {
    var { className, children, content, disabled = false, enterDelay = 0, leaveDelay = 200, placement = 'top', trigger = 'hover', visible = false, followCursor = false } = _a, rest = __rest(_a, ["className", "children", "content", "disabled", "enterDelay", "leaveDelay", "placement", "trigger", "visible", "followCursor"]);
    const [internalVisible, setInternalVisible] = useState(visible);
    const timeout = useRef();
    const mounted = useRef();
    const ref = useRef(setInternalVisible);
    useEffect(() => {
        // componentDidUpdateLogic style logic
        if (!mounted.current) {
            mounted.current = true;
        }
        else {
            setInternalVisible(visible);
        }
        return () => {
            clearTimeout(timeout.current);
            deactivate();
        };
    }, [visible]);
    const deactivateAll = () => tooltips.forEach((r, i) => {
        r(false);
        tooltips.splice(i, 1);
    });
    const deactivate = () => {
        const idx = tooltips.indexOf(ref.current);
        if (idx > -1) {
            setInternalVisible(false);
            tooltips.splice(idx, 1);
        }
    };
    return (React.createElement(ConnectedOverlay, Object.assign({}, rest, { placement: placement, trigger: trigger, followCursor: followCursor, visible: internalVisible, content: () => {
            const contentChildren = typeof content === 'function' ? content() : content;
            if (!contentChildren) {
                return null;
            }
            return (React.createElement(motion.div, { className: classNames(css$j.tooltip, className), initial: { opacity: 0, scale: 0.3 }, animate: { opacity: 1, scale: 1 }, exit: { opacity: 0, scale: 0.3 } }, contentChildren));
        }, onActivate: () => {
            if (!internalVisible) {
                deactivateAll();
                clearTimeout(timeout.current);
                timeout.current = setTimeout(() => {
                    if (!disabled) {
                        setInternalVisible(true);
                        tooltips.push(ref.current);
                    }
                }, enterDelay);
            }
        }, onDeactivate: () => {
            clearTimeout(timeout.current);
            timeout.current = setTimeout(() => deactivate(), leaveDelay);
        } }), children));
};

var css$k = ".TooltipTemplate-module_label__jiS7i {\n  font-size: 16px;\n  margin-bottom: 3px;\n  color: white; }\n\n.TooltipTemplate-module_value__1B9bc {\n  font-size: 13px;\n  color: rgba(255, 255, 255, 0.7); }\n\n.TooltipTemplate-module_subValue__10sXY {\n  display: block;\n  text-align: left;\n  padding: 3px 5px; }\n  .TooltipTemplate-module_subValue__10sXY .TooltipTemplate-module_subValueColor__1cUVB {\n    width: 5px;\n    height: 15px;\n    margin-right: 8px;\n    display: inline-block; }\n  .TooltipTemplate-module_subValue__10sXY .TooltipTemplate-module_subValueName__jhmgI {\n    margin-right: 5px; }\n";
var css$l = {"label":"TooltipTemplate-module_label__jiS7i","value":"TooltipTemplate-module_value__1B9bc","subValue":"TooltipTemplate-module_subValue__10sXY","subValueColor":"TooltipTemplate-module_subValueColor__1cUVB","subValueName":"TooltipTemplate-module_subValueName__jhmgI"};
styleInject(css$k);

const TooltipTemplate = ({ value, color, className }) => {
    if (!value) {
        return null;
    }
    const renderValues = (data, index) => {
        const fill = color(data, index);
        return (React.createElement("span", { className: css$l.subValue },
            React.createElement("span", { className: css$l.subValueColor, style: { backgroundColor: fill } }),
            React.createElement("span", { className: css$l.subValueName },
                formatValue(data.key || data.x),
                ":"),
            React.createElement("span", null, formatValue(data.value || data.y))));
    };
    const renderMultiple = (value) => {
        const excessCount = value.data.length - 15;
        const pagedValues = value.data.slice(0, 15);
        return (React.createElement(Fragment, null,
            pagedValues.map((point, i) => (React.createElement(Fragment, { key: i }, renderValues(point, i)))),
            excessCount > 0 && React.createElement("div", null,
                "...",
                excessCount,
                " more...")));
    };
    const isMultiple = Array.isArray(value.data);
    return (React.createElement("div", { className: className },
        React.createElement("div", { className: css$l.label }, formatValue(value.x)),
        React.createElement("div", { className: css$l.value },
            isMultiple && renderMultiple(value),
            !isMultiple && (React.createElement(Fragment, null, formatValue(value.value ||
                value.y))))));
};

const ChartTooltip = (_a) => {
    var { content = React.createElement(TooltipTemplate, null), value, data, color } = _a, rest = __rest(_a, ["content", "value", "data", "color"]);
    return (React.createElement(Tooltip, Object.assign({}, rest, { content: () => {
            if (!value && !data) {
                return null;
            }
            return typeof content === 'function'
                ? content(data || value, color)
                : cloneElement(content, Object.assign(Object.assign({}, content.props), { value,
                    color }));
        } })));
};

class TooltipArea extends Component {
    constructor() {
        super(...arguments);
        this.state = {};
        this.ref = createRef();
        this.transformData = memoize((series) => {
            const { inverse, isHorizontal } = this.props;
            const result = [];
            if (inverse) {
                for (const point of series) {
                    const seriesPoint = point;
                    if (Array.isArray(seriesPoint.data)) {
                        for (const nestedPoint of seriesPoint.data) {
                            const right = nestedPoint.x;
                            let idx = result.findIndex(r => {
                                const left = r.x;
                                if (left instanceof Date && right instanceof Date) {
                                    return left.getTime() === right.getTime();
                                }
                                return left === right;
                            });
                            if (idx === -1) {
                                result.push({
                                    x: nestedPoint.x,
                                    data: []
                                });
                                idx = result.length - 1;
                            }
                            const data = result[idx].data;
                            if (Array.isArray(data)) {
                                data.push(nestedPoint);
                            }
                        }
                    }
                    else {
                        result.push(point);
                    }
                }
            }
            else {
                for (const point of series) {
                    const nestedPoint = point;
                    if (Array.isArray(nestedPoint.data)) {
                        result.push(Object.assign(Object.assign({}, nestedPoint), { x: nestedPoint.key, data: nestedPoint.data.map(d => (Object.assign(Object.assign({}, d), { key: !isHorizontal ? d.x : d.y, value: !isHorizontal ? d.y : d.x }))) }));
                    }
                    else {
                        const shallowPoint = point;
                        result.push(Object.assign(Object.assign({}, shallowPoint), { 
                            // Histograms special logic...
                            x: shallowPoint.key === undefined ? shallowPoint.x0 : point.key, y: shallowPoint.value === undefined
                                ? shallowPoint.y
                                : shallowPoint.value }));
                    }
                }
            }
            return result;
        });
    }
    getXCoord(x, y) {
        const { isRadial, width, height } = this.props;
        // If the shape is radial, we need to convert the X coords to a radial format.
        if (isRadial) {
            const outerRadius = Math.min(width, height) / 2;
            let rad = Math.atan2(y - outerRadius, x - outerRadius) + Math.PI / 2;
            // TODO: Figure out what the 'correct' way to do this is...
            if (rad < 0) {
                rad += Math.PI * 2;
            }
            return rad;
        }
        return x;
    }
    onMouseMove(event) {
        const { xScale, yScale, onValueEnter, height, width, data, isRadial, isHorizontal, placement } = this.props;
        const { value } = this.state;
        const transformed = this.transformData(data);
        // Get our default placement
        let newPlacement = placement;
        if (!placement) {
            if (isHorizontal) {
                newPlacement = 'right';
            }
            else {
                newPlacement = 'top';
            }
        }
        // Get the path container element
        let target = this.ref.current;
        const { y, x } = getPositionForTarget({
            target: target,
            // Manually pass the x/y from the event
            clientX: event.clientX,
            clientY: event.clientY
        });
        // Need to flip scales/coords if we are a horz layout
        let keyScale;
        let valueScale;
        let coord;
        if (isHorizontal) {
            keyScale = yScale;
            valueScale = xScale;
            coord = y;
        }
        else {
            coord = this.getXCoord(x, y);
            keyScale = xScale;
            valueScale = yScale;
        }
        const newValue = getClosestPoint(coord, keyScale, transformed);
        if (!isEqual(newValue, value) && newValue) {
            const pointX = keyScale(newValue.x);
            let pointY = valueScale(newValue.y);
            let marginX = 0;
            let marginY = 0;
            if (isNaN(pointY)) {
                pointY = height / 2;
                marginX = 10;
                if (!placement) {
                    newPlacement = 'right';
                }
            }
            else {
                marginY = -10;
            }
            // If the points didn't change, don't trigger an update
            if (pointX === this.prevX && pointY === this.prevY) {
                return;
            }
            this.prevY = pointY;
            this.prevX = pointX;
            const target = event.target;
            const { top, left } = target.getBoundingClientRect();
            let offsetX = 0;
            let offsetY = 0;
            if (isRadial) {
                // If its radial, we need to convert the coords to radial format
                const outerRadius = Math.min(width, height) / 2;
                offsetX = pointY * Math.cos(pointX - Math.PI / 2) + outerRadius;
                offsetY = pointY * Math.sin(pointX - Math.PI / 2) + outerRadius;
            }
            else {
                offsetX = pointX;
                offsetY = pointY;
            }
            offsetX += left + marginX;
            offsetY += top + marginY;
            this.setState({
                placement: newPlacement,
                visible: true,
                value: newValue,
                offsetX,
                offsetY
            });
            onValueEnter({
                visible: true,
                value: newValue,
                pointY,
                pointX,
                offsetX,
                offsetY,
                nativeEvent: event
            });
        }
    }
    onMouseLeave() {
        this.prevX = undefined;
        this.prevY = undefined;
        this.setState({
            value: undefined,
            visible: false
        });
        this.props.onValueLeave();
    }
    getTooltipReference() {
        const { offsetX, offsetY } = this.state;
        return {
            width: 4,
            height: 4,
            top: offsetY,
            left: offsetX
        };
    }
    renderRadial() {
        let { height, width, innerRadius, outerRadius } = this.props;
        innerRadius = innerRadius || 0;
        outerRadius = outerRadius || Math.min(width, height) / 2;
        const d = arc()({
            innerRadius,
            outerRadius,
            startAngle: 180,
            endAngle: Math.PI / 2
        });
        return (React.createElement("path", { d: d, opacity: "0", cursor: "auto", ref: this.ref, onMouseMove: bind(this.onMouseMove, this) }));
    }
    renderLinear() {
        const { height, width } = this.props;
        return (React.createElement("rect", { height: height, ref: this.ref, width: width, opacity: 0, cursor: "auto", onMouseMove: bind(this.onMouseMove, this) }));
    }
    render() {
        const { isRadial, children, tooltip, disabled, color } = this.props;
        const { visible, placement, value } = this.state;
        return (React.createElement(Fragment, null,
            disabled && children,
            !disabled && (React.createElement("g", { onMouseLeave: bind(this.onMouseLeave, this) },
                isRadial && this.renderRadial(),
                !isRadial && this.renderLinear(),
                React.createElement(CloneElement, { element: tooltip, visible: visible, placement: placement, modifiers: {
                        offset: {
                            offset: '0, 15px'
                        }
                    }, reference: this.getTooltipReference(), color: color, value: value }),
                children))));
    }
}
TooltipArea.defaultProps = {
    isRadial: false,
    tooltip: React.createElement(ChartTooltip, null),
    inverse: true,
    onValueEnter: () => undefined,
    onValueLeave: () => undefined
};

class ZoomPan extends Component {
    constructor() {
        super(...arguments);
        this.zoomRef = createRef();
        this.panRef = createRef();
        this.state = {
            isZooming: false,
            isPanning: false,
            matrix: identity()
        };
    }
    static getDerivedStateFromProps(props, state) {
        // TODO: the types in the library don't seem to be correct...
        const matrix = transform(fromDefinition([
            { type: 'translate', tx: props.x, ty: props.y },
            { type: 'scale', sx: props.scale, sy: props.scale }
        ]));
        if (!isEqual(matrix, state.matrix)) {
            return {
                matrix
            };
        }
        return null;
    }
    onPanStart(event) {
        this.setState({
            isPanning: true
        });
        this.props.onPanStart(event);
    }
    onPanMove(event) {
        this.props.onZoomPan({
            scale: this.props.scale,
            x: event.x,
            y: event.y,
            type: 'pan',
            nativeEvent: event.nativeEvent
        });
        this.props.onPanMove(event);
    }
    onPanEnd(event) {
        this.setState({ isPanning: false });
        this.props.onPanEnd(event);
    }
    onZoom(event) {
        this.props.onZoomPan({
            x: event.x,
            y: event.y,
            scale: event.scale,
            nativeEvent: event.nativeEvent,
            type: 'zoom'
        });
        this.props.onZoom(event);
    }
    onZoomEnd() {
        this.setState({
            isZooming: false
        });
        this.props.onZoomEnd();
    }
    render() {
        const { height, width, children, disabled, pannable, maxZoom, minZoom, zoomable, scale, x, y, disableMouseWheel, constrain, zoomStep, onPanCancel, requireZoomModifier, globalPanning } = this.props;
        const { isZooming, isPanning } = this.state;
        const cursor = pannable ? 'move' : 'auto';
        const selection = isZooming || isPanning ? 'none' : 'auto';
        const matrix = fromObject(this.state.matrix);
        return (React.createElement(Pan, { x: x, y: y, scale: scale, matrix: matrix, constrain: constrain, height: height, width: width, disabled: !pannable || disabled, ref: this.panRef, globalPanning: globalPanning, onPanStart: bind(this.onPanStart, this), onPanMove: bind(this.onPanMove, this), onPanEnd: bind(this.onPanEnd, this), onPanCancel: onPanCancel },
            React.createElement(Zoom, { ref: this.zoomRef, disabled: !zoomable || disabled, scaleFactor: zoomStep, disableMouseWheel: disableMouseWheel, maxZoom: maxZoom, minZoom: minZoom, scale: scale, x: x, y: y, style: { cursor }, requireZoomModifier: requireZoomModifier, matrix: matrix, onZoom: bind(this.onZoom, this), onZoomEnd: bind(this.onZoomEnd, this) },
                !disabled && (React.createElement("rect", { height: height, width: width, opacity: 0, className: "pan-container" })),
                React.createElement("g", { style: {
                        pointerEvents: selection,
                        userSelect: selection
                    } }, children))));
    }
}
ZoomPan.defaultProps = {
    maxZoom: 10,
    minZoom: 0,
    zoomStep: 0.1,
    pannable: true,
    zoomable: true,
    constrain: true,
    height: 0,
    width: 0,
    x: 0,
    y: 0,
    scale: 1,
    globalPanning: true,
    onPanStart: () => undefined,
    onPanMove: () => undefined,
    onPanEnd: () => undefined,
    onPanCancel: () => undefined,
    onZoom: () => undefined,
    onZoomEnd: () => undefined
};

/**
 * Gets the X Scale function.
 */
function getXScale({ type, roundDomains, data, width, domain, padding, scaled, isMultiSeries = false, isDiverging = false }) {
    let scale;
    if (type === 'time' || type === 'duration' || type === 'value') {
        if (type === 'time') {
            scale = scaleTime().rangeRound([0, width]);
        }
        else {
            scale = scaleLinear().rangeRound([0, width]);
        }
        scale = scale.domain(domain || getXDomain({ data, scaled, isDiverging }));
    }
    else {
        if (!domain) {
            if (isMultiSeries) {
                domain = uniqueBy(data, d => d.key);
            }
            else {
                domain = uniqueBy(data, d => d.x);
            }
        }
        scale = scaleBand()
            .rangeRound([0, width])
            .padding(padding || 0)
            .domain(domain);
    }
    return roundDomains ? scale.nice() : scale;
}
/**
 * Gets the Y Scale function.
 */
function getYScale({ type, height, data, domain, roundDomains = false, scaled = false, padding = 0, isMultiSeries = false, isDiverging = false }) {
    let scale;
    if (type === 'time' || type === 'value' || type === 'duration') {
        scale = scaleLinear()
            .range([height, 0])
            .domain(domain || getYDomain({ data, scaled, isDiverging }));
    }
    else {
        if (!domain) {
            if (isMultiSeries) {
                domain = uniqueBy(data, d => d.key);
            }
            else {
                domain = uniqueBy(data, d => d.y);
            }
        }
        scale = scaleBand()
            .rangeRound([height, 0])
            .padding(padding)
            .domain(domain);
    }
    return roundDomains ? scale.nice() : scale;
}

/**
 * Get a linear scale for the mariemko chart.
 */
const getMarimekkoScale = (width, roundDomains) => {
    const scale = scaleLinear().rangeRound([0, width]);
    return roundDomains ? scale.nice() : scale;
};
/**
 * Builds a fake scale function to get a group scale for a marimekko value scale.
 */
const getMarimekkoGroupScale = ({ data, width, valueScale, padding }) => {
    const domain = uniqueBy(data, d => d.key);
    const barCount = data.length;
    const widthMinusPadding = width - padding * (barCount - 1);
    const xMultiplier = widthMinusPadding / width;
    // Given a data series, find the x0/x1 for it.
    const getXRange = series => {
        const [val] = series.data;
        const x0 = valueScale(val.x0);
        const x1 = valueScale(val.x1);
        return { x0, x1 };
    };
    const scale = arg => {
        let result = 0;
        const index = data.findIndex(d => d.key === arg);
        const series = data[index];
        if (series && series.data && series.data.length) {
            const { x1, x0 } = getXRange(series);
            result = (x1 - x0) / 2 + x0;
            if (padding) {
                result = result * xMultiplier + index * padding;
            }
        }
        return result;
    };
    scale.range = () => [0, width];
    scale.domain = () => domain;
    // Special invert function for marimekko
    scale.mariemkoInvert = (offset) => {
        let found;
        for (let i = 0; i < domain.length; i++) {
            const attr = domain[i];
            const series = data[i];
            const { x1, x0 } = getXRange(series);
            if (offset >= x0 - padding / 2 && offset <= x1 - padding / 2) {
                found = attr;
                break;
            }
        }
        return found;
    };
    return scale;
};

/**
 * Get the group scale aka x0.
 */
function getGroupScale({ dimension, padding, data, direction = 'vertical' }) {
    const domain = uniqueBy(data, d => d.key);
    const spacing = domain.length / (dimension / padding + 1);
    const range = direction === 'vertical' ? [0, dimension] : [dimension, 0];
    return scaleBand()
        .rangeRound(range)
        .paddingInner(spacing)
        .paddingOuter(spacing / 2)
        .domain(domain);
}
/**
 * Get the inner scale aka x1.
 */
function getInnerScale({ groupScale, padding, data, prop = 'x' }) {
    const dimension = groupScale.bandwidth();
    const domain = uniqueBy(data, d => d.data, d => d[prop]);
    const spacing = domain.length / (dimension / padding + 1);
    return scaleBand()
        .rangeRound([0, dimension])
        .paddingInner(spacing)
        .domain(domain);
}

/**
 * Get the Y Scale for a given set of radiuses.
 * Reference: https://github.com/d3/d3-scale/issues/90
 */
const getRadialYScale = (innerRadius, outerRadius, domain) => {
    if (domain[0] === 0 && domain[1] === 0) {
        // If all values are 0, set the domain to [0, 1], so the zero values are
        // all at the bottom of the chart, not the middle.
        domain = [0, 1];
    }
    const y = scaleLinear()
        .range([innerRadius * innerRadius, outerRadius * outerRadius])
        .domain(domain);
    const yScale = Object.assign(d => Math.sqrt(y(d)), y);
    return yScale;
};

class ChartZoomPan extends Component {
    onZoomPan(event) {
        const { width, data, axisType, roundDomains, onZoomPan } = this.props;
        const can = event.type === 'zoom' || (event.type === 'pan' && event.scale > 1);
        if (can) {
            const scale = getXScale({
                width: width,
                type: axisType,
                roundDomains,
                data
            });
            const newScale = scale.copy().domain(scale
                .range()
                .map(x => (x - event.x) / event.scale)
                .map(scale.clamp(true).invert, event.x));
            onZoomPan({
                domain: newScale.domain(),
                isZoomed: event.scale !== 1
            });
        }
    }
    getOffset() {
        let zoomOffset = {
            scale: undefined,
            x: undefined
        };
        const { disabled, domain, width, data, axisType, roundDomains } = this.props;
        if (!disabled && domain) {
            const xScale = getXScale({
                width,
                type: axisType,
                roundDomains,
                data
            });
            let offset = xScale(domain[0]);
            const endOffset = xScale(domain[1]);
            const scale = width / (endOffset - offset);
            // Apply the new scale to the offset so its scaled correctly
            offset = offset * scale;
            zoomOffset = {
                scale: scale,
                x: -offset
            };
        }
        return zoomOffset;
    }
    render() {
        const _a = this.props, { data, height, children, width, onZoomPan } = _a, rest = __rest(_a, ["data", "height", "children", "width", "onZoomPan"]);
        const { scale, x } = this.getOffset();
        return (React.createElement(ZoomPan, Object.assign({}, rest, { scale: scale, x: x, height: height, width: width, pannable: scale > 1, onZoomPan: bind(this.onZoomPan, this) }), children));
    }
}
ChartZoomPan.defaultProps = {
    onZoomPan: () => undefined
};

const DEFAULT_TRANSITION = {
    type: 'spring',
    velocity: 10,
    damping: 50
};

const MotionPath = (_a) => {
    var { custom, transition } = _a, rest = __rest(_a, ["custom", "transition"]);
    const d = useMotionValue(custom.exit.d);
    const prevPath = useMotionValue(custom.exit.d);
    const spring = useSpring(prevPath, Object.assign(Object.assign({}, DEFAULT_TRANSITION), { from: 0, to: 1 }));
    useEffect(() => {
        const interpolator = interpolate$1(prevPath.get(), custom.enter.d);
        const unsub = spring.onChange(v => d.set(interpolator(v)));
        prevPath.set(custom.enter.d);
        return unsub;
    });
    const _b = custom.enter, { d: enterD } = _b, enterRest = __rest(_b, ["d"]);
    const _c = custom.exit, exitRest = __rest(_c, ["d"]);
    return (React.createElement(motion.path, Object.assign({}, rest, { initial: exitRest, exit: exitRest, animate: enterRest, transition: transition, d: transition.type !== false ? d : enterD })));
};

/**
 * Color Schemes
 * Credits: https://gka.github.io/chroma.js/#chroma-brewer
 */
const schemes = Object.assign({ cybertron: chroma
        .scale(['#2d60e8', '#26efb5'])
        .correctLightness()
        .colors(8) }, chroma.brewer);

/**
 * Given a point, get the key attributes for it.
 */
const rangeHelper = (point, attribute) => point.map((r, i) => {
    if (r) {
        if (r[attribute] !== undefined) {
            return r[attribute];
        }
        else if (r.data && r.data[attribute] !== undefined) {
            return r.data[attribute];
        }
    }
    return i;
});
/**
 * Get a color given a range.
 */
const getColor = (props) => {
    let { point, colorScheme, attribute, index, data, active, isMultiSeries, domain, key, scale } = Object.assign({ attribute: 'key', isMultiSeries: false, scale: scaleOrdinal }, props);
    if (typeof colorScheme === 'string' && schemes[colorScheme]) {
        colorScheme = schemes[colorScheme];
    }
    if (Array.isArray(colorScheme)) {
        if (!domain) {
            if (isMultiSeries && Array.isArray(data)) {
                const maxIdx = maxIndex(data, d => d.data.length);
                const maxVal = data[maxIdx];
                data = maxVal.data;
            }
            domain = rangeHelper(data, attribute);
        }
        key = key !== undefined ? key : point[attribute];
        return scale(colorScheme).domain(domain)(key);
    }
    else if (typeof colorScheme === 'function') {
        return colorScheme(point, index, active);
    }
    else {
        return colorScheme;
    }
};

var css$m = ".ScatterPoint-module_inactive__2qwES {\n  opacity: 0.2; }\n";
var css$n = {"inactive":"ScatterPoint-module_inactive__2qwES"};
styleInject(css$m);

class ScatterPoint extends Component {
    constructor() {
        super(...arguments);
        this.rect = createRef();
        this.state = {
            active: false
        };
    }
    onMouseEnter() {
        this.setState({ active: true });
        this.props.onMouseEnter(this.props.data);
    }
    onMouseLeave() {
        this.setState({ active: false });
        this.props.onMouseLeave(this.props.data);
    }
    onClick() {
        this.props.onClick(this.props.data);
    }
    getYPosition() {
        const { yScale, data } = this.props;
        let cy = yScale(data.y1);
        if (yScale.bandwidth) {
            const width = yScale.bandwidth();
            cy = cy + width / 2;
        }
        return cy;
    }
    getEnter() {
        const { xScale, data } = this.props;
        return {
            x: xScale(data.x),
            y: this.getYPosition()
        };
    }
    getExit() {
        const { xScale, data, yScale } = this.props;
        const [yStartDomain] = yScale.domain();
        return {
            y: yScale(yStartDomain),
            x: xScale(data.x)
        };
    }
    getTransition() {
        const { animated, index } = this.props;
        if (animated) {
            return Object.assign(Object.assign({}, DEFAULT_TRANSITION), { delay: index * 0.005 });
        }
        else {
            return {
                type: false,
                delay: 0
            };
        }
    }
    renderCircle() {
        const { data, index, size, color, cursor, id } = this.props;
        const fill = getColor({
            colorScheme: color,
            index,
            point: data
        });
        const r = typeof size === 'function' ? size(data) : size;
        const enter = this.getEnter();
        const exit = this.getExit();
        const extras = constructFunctionProps(this.props, data);
        const transition = this.getTransition();
        const initial = {
            cx: exit.x,
            cy: exit.y,
            fill,
            r,
            opacity: 0
        };
        return (React.createElement(motion.circle, { key: `symbol-${id}-${data.id}`, className: extras.className, style: Object.assign(Object.assign({}, extras.style), { cursor }), initial: initial, animate: {
                cx: enter.x,
                cy: enter.y,
                opacity: 1,
                fill,
                r
            }, exit: initial, transition: transition }));
    }
    renderSymbol() {
        const { data, symbol, id } = this.props;
        const enter = this.getEnter();
        const exit = this.getExit();
        const renderedSymbol = symbol(data);
        const extras = constructFunctionProps(this.props, data);
        const transition = this.getTransition();
        const initial = {
            translateX: exit.x,
            translateY: exit.y,
            opacity: 0
        };
        return (React.createElement(motion.g, Object.assign({ key: `symbol-${id}-${data.id}` }, extras, { initial: initial, animate: {
                translateX: enter.x,
                translateY: enter.y,
                opacity: 1
            }, exit: initial, transition: transition }), renderedSymbol));
    }
    render() {
        const { symbol, tooltip, data } = this.props;
        const { active } = this.state;
        return (React.createElement(Fragment, null,
            React.createElement("g", { ref: this.rect, onMouseEnter: bind(this.onMouseEnter, this), onMouseLeave: bind(this.onMouseLeave, this), onClick: bind(this.onClick, this), className: classNames({
                    [css$n.inactive]: !this.props.active
                }) },
                symbol && this.renderSymbol(),
                !symbol && this.renderCircle()),
            tooltip && !tooltip.props.disabled && (React.createElement(CloneElement, { element: tooltip, visible: active, reference: this.rect, value: data }))));
    }
}
ScatterPoint.defaultProps = {
    active: true,
    tooltip: React.createElement(ChartTooltip, null),
    cursor: 'pointer',
    size: 4,
    color: schemes.cybertron[0],
    onClick: () => undefined,
    onMouseEnter: () => undefined,
    onMouseLeave: () => undefined
};

// For bubble charts, often symbols exceed the area
// and we want to add a little bit of padding to prevent clipping
const PADDING = 25;
const HALF_PADDING = PADDING / 2;
class ScatterSeries extends Component {
    renderPoint(pointData, index) {
        const _a = this.props, { data, width, id, isZoomed, point, activeIds } = _a, rest = __rest(_a, ["data", "width", "id", "isZoomed", "point", "activeIds"]);
        let pointId;
        if (pointData.id) {
            pointId = pointData.id;
        }
        const key = pointId || index;
        const active = !(activeIds && activeIds.length) || activeIds.includes(pointId);
        const visible = point.props.visible;
        if (visible && !visible(pointData, index)) {
            return React.createElement(Fragment, { key: key });
        }
        return (React.createElement(CloneElement, Object.assign({ element: point, key: key }, rest, { id: id, data: pointData, index: index, active: active })));
    }
    render() {
        const { data, height, width, id, isZoomed } = this.props;
        return (React.createElement(Fragment, null,
            React.createElement("defs", null,
                React.createElement("clipPath", { id: `${id}-path` },
                    React.createElement("rect", { width: isZoomed ? width : width + PADDING, height: height + PADDING, x: isZoomed ? 0 : -HALF_PADDING, y: -HALF_PADDING }))),
            React.createElement("g", { clipPath: `url(#${id}-path)` }, data.map((data, index) => this.renderPoint(data, index)))));
    }
}
ScatterSeries.defaultProps = {
    animated: true,
    point: React.createElement(ScatterPoint, null)
};

var css$o = ".ScatterPlot-module_scatterPlot__gOR7J {\n  overflow: visible; }\n";
var css$p = {"scatterPlot":"ScatterPlot-module_scatterPlot__gOR7J"};
styleInject(css$o);

class ScatterPlot extends Component {
    constructor(props) {
        super(props);
        this.getData = memoize(data => {
            return buildShallowChartData(data);
        });
        const zoom = props.zoomPan ? props.zoomPan.props : { domain: undefined };
        const zoomControlled = !zoom.hasOwnProperty('domain');
        this.state = {
            isZoomed: !!zoom.domain,
            zoomDomain: zoom.domain,
            zoomControlled
        };
    }
    static getDerivedStateFromProps(props, state) {
        if (props.zoomPan) {
            const zoom = props.zoomPan.props;
            if (!state.zoomControlled && zoom.domain !== state.zoomDomain) {
                return {
                    zoomDomain: zoom.domain,
                    isZoomed: !!zoom.domain
                };
            }
        }
        return null;
    }
    getScales(data, chartHeight, chartWidth) {
        const { xAxis, yAxis } = this.props;
        const { zoomDomain } = this.state;
        const yScale = getYScale({
            roundDomains: yAxis.props.roundDomains,
            type: yAxis.props.type,
            height: chartHeight,
            data,
            domain: yAxis.props.domain
        });
        const xScale = getXScale({
            width: chartWidth,
            type: xAxis.props.type,
            roundDomains: xAxis.props.roundDomains,
            data,
            domain: zoomDomain || xAxis.props.domain
        });
        return {
            data,
            yScale,
            xScale
        };
    }
    onZoomPan(event) {
        if (this.state.zoomControlled) {
            this.setState({
                zoomDomain: event.domain,
                isZoomed: event.isZoomed,
                preventAnimation: true
            });
            clearTimeout(this.timeout);
            this.timeout = setTimeout(() => this.setState({ preventAnimation: false }), 500);
        }
    }
    renderChart(containerProps) {
        const { chartHeight, chartWidth, id, updateAxes } = containerProps;
        const { series, xAxis, yAxis, gridlines, brush, zoomPan, secondaryAxis } = this.props;
        const { isZoomed, zoomDomain, preventAnimation } = this.state;
        const data = this.getData(this.props.data);
        const { yScale, xScale } = this.getScales(data, chartHeight, chartWidth);
        const animated = preventAnimation === true ? false : series.props.animated;
        return (React.createElement(Fragment, null,
            containerProps.chartSized && gridlines && (React.createElement(CloneElement, { element: gridlines, height: chartHeight, width: chartWidth, yScale: yScale, xScale: xScale, yAxis: yAxis.props, xAxis: xAxis.props })),
            React.createElement(CloneElement, { element: xAxis, height: chartHeight, width: chartWidth, scale: xScale, onDimensionsChange: bind(updateAxes, this, 'horizontal') }),
            React.createElement(CloneElement, { element: yAxis, height: chartHeight, width: chartWidth, scale: yScale, onDimensionsChange: bind(updateAxes, this, 'vertical') }),
            secondaryAxis &&
                secondaryAxis.map((axis, i) => (React.createElement(CloneElement, { key: i, element: axis, height: chartHeight, width: chartWidth, onDimensionsChange: bind(updateAxes, this, 'horizontal') }))),
            containerProps.chartSized && (React.createElement(CloneElement, { element: brush, height: chartHeight, width: chartWidth, scale: xScale },
                React.createElement(CloneElement, { element: zoomPan, onZoomPan: bind(this.onZoomPan, this), height: chartHeight, width: chartWidth, axisType: xAxis.props.type, roundDomains: xAxis.props.roundDomains, data: data, domain: zoomDomain },
                    React.createElement(CloneElement, { element: series, id: `area-series-${id}`, data: data, height: chartHeight, width: chartWidth, yScale: yScale, xScale: xScale, isZoomed: isZoomed, animated: animated }))))));
    }
    render() {
        const { xAxis, yAxis, id, width, height, margins, className } = this.props;
        return (React.createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: isAxisVisible(xAxis.props), yAxisVisible: isAxisVisible(yAxis.props), className: classNames(css$p.scatterPlot, className) }, props => this.renderChart(props)));
    }
}
ScatterPlot.defaultProps = {
    data: [],
    xAxis: React.createElement(LinearXAxis, { type: "time" }),
    yAxis: React.createElement(LinearYAxis, { type: "value" }),
    series: React.createElement(ScatterSeries, null),
    gridlines: React.createElement(GridlineSeries, null),
    brush: null,
    zoomPan: null
};

var css$q = ".PointSeries-module_point__3ORLE {\n  stroke: rgba(255, 255, 255, 0.5);\n  stroke-width: 1px; }\n";
var css$r = {"point":"PointSeries-module_point__3ORLE"};
styleInject(css$q);

class PointSeries extends Component {
    isVisible(point, index) {
        const { show, activeValues, data } = this.props;
        const isActive = activeValues && point && isEqual(activeValues.x, point.x);
        if (show === 'hover') {
            return isActive;
        }
        else if (show === 'first') {
            if (activeValues) {
                return isActive;
            }
            else {
                return index === 0;
            }
        }
        else if (show === 'last') {
            if (activeValues) {
                return isActive;
            }
            else {
                return index === data.length - 1;
            }
        }
        return show;
    }
    render() {
        const { data, xScale, yScale, animated, point, color, height, width, id } = this.props;
        return (React.createElement(ScatterSeries, { height: height, width: width, id: id, animated: animated, data: data, xScale: xScale, yScale: yScale, point: React.createElement(CloneElement, { element: point, color: color, className: css$r.point, size: 4, tooltip: null, visible: this.isVisible.bind(this) }) }));
    }
}
PointSeries.defaultProps = {
    show: 'hover',
    point: React.createElement(ScatterPoint, null)
};

class Area extends Component {
    getAreaPath(data) {
        const { interpolation } = this.props;
        const fn = area()
            .x((d) => d.x)
            .y0((d) => d.y0)
            .y1((d) => d.y1)
            .curve(interpolate(interpolation));
        return fn(data);
    }
    getCoords() {
        const { data, xScale, yScale } = this.props;
        return data.map((item) => ({
            x: xScale(item.x),
            x1: xScale(item.x) - xScale(item.x1),
            y: yScale(item.y),
            y0: yScale(item.y0),
            y1: yScale(item.y1)
        }));
    }
    getAreaEnter(coords) {
        const areaPath = this.getAreaPath(coords);
        return {
            d: areaPath === null ? undefined : areaPath
        };
    }
    getAreaExit() {
        const { yScale, data, xScale } = this.props;
        const maxY = Math.max(...yScale.range());
        const coords = data.map((item) => ({
            x: xScale(item.x),
            x1: 0,
            y: 0,
            y1: maxY,
            y0: maxY
        }));
        const areaPath = this.getAreaPath(coords);
        return {
            d: areaPath === null ? undefined : areaPath
        };
    }
    getFill() {
        const { mask, id, gradient } = this.props;
        if (mask) {
            return `url(#mask-pattern-${id})`;
        }
        else {
            if (gradient) {
                return `url(#gradient-${id})`;
            }
            return '';
        }
    }
    getTransition() {
        const { animated, index } = this.props;
        if (animated) {
            return Object.assign(Object.assign({}, DEFAULT_TRANSITION), { delay: index * 0.05 });
        }
        else {
            return {
                type: false,
                delay: 0
            };
        }
    }
    renderArea(coords) {
        const { mask, id, data } = this.props;
        const fill = this.getFill();
        const maskPath = mask ? `url(#mask-${id})` : '';
        const enter = this.getAreaEnter(coords);
        const exit = this.getAreaExit();
        const extras = constructFunctionProps(this.props, data);
        const transition = this.getTransition();
        return (React.createElement(MotionPath, Object.assign({}, extras, { pointerEvents: "none", mask: maskPath, fill: fill, transition: transition, custom: {
                enter,
                exit
            } })));
    }
    render() {
        const { id, gradient, mask, data, color, index } = this.props;
        const coords = this.getCoords();
        const stroke = color(data, index);
        return (React.createElement(Fragment, null,
            this.renderArea(coords),
            mask && (React.createElement(Fragment, null,
                React.createElement(Mask, { id: `mask-${id}`, fill: `url(#gradient-${id})` }),
                React.createElement(CloneElement, { element: mask, id: `mask-pattern-${id}`, fill: stroke }))),
            gradient && (React.createElement(CloneElement, { element: gradient, id: `gradient-${id}`, color: stroke }))));
    }
}
Area.defaultProps = {
    gradient: React.createElement(Gradient, null),
    interpolation: 'linear'
};

class Line extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {};
        this.ghostPathRef = createRef();
    }
    componentDidMount() {
        if (this.ghostPathRef.current) {
            this.setState({
                pathLength: this.ghostPathRef.current.getTotalLength()
            });
        }
    }
    componentDidUpdate(prevProps) {
        if (this.ghostPathRef.current &&
            (prevProps.data !== this.props.data ||
                prevProps.width !== this.props.width)) {
            this.setState({
                pathLength: this.ghostPathRef.current.getTotalLength()
            });
        }
    }
    getLinePath(data) {
        const { showZeroStroke, interpolation } = this.props;
        const fn = line()
            .x((d) => d.x)
            .y((d) => d.y1)
            .defined((d) => showZeroStroke || calculateShowStroke(d, data))
            .curve(interpolate(interpolation));
        return fn(data);
    }
    getCoords() {
        const { data, xScale, yScale } = this.props;
        return data.map((item) => ({
            x: xScale(item.x),
            x1: xScale(item.x) - xScale(item.x1),
            y: yScale(item.y),
            y0: yScale(item.y0),
            y1: yScale(item.y1)
        }));
    }
    getLineEnter(coords) {
        const { hasArea } = this.props;
        const { pathLength } = this.state;
        const linePath = this.getLinePath(coords);
        let strokeDasharray = '';
        if (!hasArea && pathLength !== undefined) {
            strokeDasharray = `${pathLength} ${pathLength}`;
        }
        return {
            d: linePath === null ? undefined : linePath,
            strokeDashoffset: 0,
            strokeDasharray: strokeDasharray
        };
    }
    getLineExit() {
        const { hasArea, yScale, xScale, data } = this.props;
        const { pathLength } = this.state;
        let coords;
        if (hasArea) {
            const maxY = Math.max(...yScale.range());
            coords = data.map((item) => ({
                x: xScale(item.x),
                x1: 0,
                y: maxY,
                y1: maxY,
                y0: maxY
            }));
        }
        else {
            coords = this.getCoords();
        }
        const linePath = this.getLinePath(coords);
        let strokeDasharray = '';
        let strokeDashoffset = 0;
        if (!hasArea && pathLength !== undefined) {
            strokeDasharray = `${pathLength} ${pathLength}`;
            strokeDashoffset = pathLength;
        }
        return {
            d: linePath === null ? undefined : linePath,
            strokeDasharray,
            strokeDashoffset
        };
    }
    getTransition() {
        const { animated, index, hasArea } = this.props;
        if (animated) {
            return Object.assign(Object.assign({}, DEFAULT_TRANSITION), { delay: hasArea ? 0 : index * 0.05 });
        }
        else {
            return {
                type: false,
                delay: 0
            };
        }
    }
    render() {
        const { data, color, index, strokeWidth, hasArea } = this.props;
        const { pathLength } = this.state;
        const coords = this.getCoords();
        const stroke = color(data, index);
        const enter = this.getLineEnter(coords);
        const exit = this.getLineExit();
        const extras = constructFunctionProps(this.props, data);
        const transition = this.getTransition();
        const showLine = hasArea || pathLength !== undefined;
        return (React.createElement(Fragment, null,
            showLine && (React.createElement(MotionPath, Object.assign({}, extras, { pointerEvents: "none", stroke: stroke, strokeWidth: strokeWidth, fill: "none", transition: transition, custom: {
                    enter,
                    exit
                } }))),
            !hasArea && (React.createElement("path", { opacity: "0", d: enter.d, ref: this.ghostPathRef, pointerEvents: "none" }))));
    }
}
Line.defaultProps = {
    showZeroStroke: true,
    strokeWidth: 3
};

// For area charts, often symbols exceed the area
// and we want to add a little bit of padding to prevent clipping
const PADDING$1 = 25;
const HALF_PADDING$1 = PADDING$1 / 2;
class AreaSeries extends Component {
    constructor() {
        super(...arguments);
        this.state = {};
    }
    getColor(point, index) {
        const { colorScheme, data } = this.props;
        const { activeValues } = this.state;
        const key = Array.isArray(point) ? point[0].key : point.key;
        return getColor({
            data,
            colorScheme,
            active: activeValues,
            point,
            index,
            key
        });
    }
    onValueEnter(event) {
        this.setState({
            activePoint: event.pointX,
            activeValues: event.value
        });
    }
    onValueLeave() {
        this.setState({
            activePoint: undefined,
            activeValues: undefined
        });
    }
    renderArea(data, index = 0) {
        const { id, width, xScale, yScale, area, line, interpolation, animated } = this.props;
        return (React.createElement(Fragment, null,
            line && (React.createElement(CloneElement, { element: line, xScale: xScale, yScale: yScale, data: data, width: width, index: index, hasArea: area !== null, animated: animated, interpolation: interpolation, color: this.getColor.bind(this) })),
            area && (React.createElement(CloneElement, { element: area, id: `${id}-area-${index}`, xScale: xScale, yScale: yScale, data: data, index: index, animated: animated, interpolation: interpolation, color: this.getColor.bind(this) }))));
    }
    renderSymbols(data, index = 0) {
        const { xScale, yScale, symbols, id, height, width, animated, area } = this.props;
        const { activeValues } = this.state;
        const visible = symbols !== null;
        const activeSymbols = (symbols && symbols.props.activeValues) || activeValues;
        // Animations are only valid for Area
        const isAnimated = area !== undefined && animated && !activeSymbols;
        return (React.createElement(Fragment, null, visible && (React.createElement(CloneElement, { element: symbols, key: `point-series-${id}`, id: id, height: height, width: width, activeValues: activeSymbols, xScale: xScale, yScale: yScale, index: index, data: data, animated: isAnimated, color: () => this.getColor(data, index) }))));
    }
    renderMarkLine() {
        const { height, markLine } = this.props;
        const { activePoint, activeValues } = this.state;
        return (React.createElement(Fragment, null, activeValues && markLine && (React.createElement(CloneElement, { element: markLine, height: height, pointX: activePoint }))));
    }
    renderSingleSeries(data) {
        return (React.createElement(Fragment, null,
            this.renderArea(data),
            this.renderMarkLine(),
            this.renderSymbols(data)));
    }
    renderMultiSeries(data) {
        return (React.createElement(Fragment, null,
            data
                .map((point, index) => (React.createElement(Fragment, { key: `${point.key.toString()}` }, this.renderArea(point.data, index))))
                .reverse(),
            this.renderMarkLine(),
            data
                .map((point, index) => (React.createElement(Fragment, { key: `${point.key.toString()}` }, this.renderSymbols(point.data, index))))
                .reverse()));
    }
    render() {
        const { data, height, id, width, isZoomed, tooltip, xScale, yScale, type } = this.props;
        const isMulti = type === 'grouped' || type === 'stacked' || type === 'stackedNormalized';
        return (React.createElement(Fragment, null,
            React.createElement("defs", null,
                React.createElement("clipPath", { id: `${id}-path` },
                    React.createElement("rect", { width: isZoomed ? width : width + PADDING$1, height: height + PADDING$1, x: isZoomed ? 0 : -HALF_PADDING$1, y: -HALF_PADDING$1 }))),
            React.createElement(CloneElement, { element: tooltip, xScale: xScale, yScale: yScale, data: data, height: height, width: width, color: this.getColor.bind(this), onValueEnter: bind(this.onValueEnter, this), onValueLeave: bind(this.onValueLeave, this) },
                React.createElement("g", { clipPath: `url(#${id}-path)` },
                    isMulti &&
                        this.renderMultiSeries(data),
                    !isMulti &&
                        this.renderSingleSeries(data)))));
    }
}
AreaSeries.defaultProps = {
    colorScheme: 'cybertron',
    animated: true,
    interpolation: 'linear',
    type: 'standard',
    line: React.createElement(Line, null),
    area: React.createElement(Area, null),
    markLine: React.createElement(MarkLine, null),
    tooltip: React.createElement(TooltipArea, null),
    symbols: React.createElement(PointSeries, null)
};

class StackedNormalizedAreaSeries extends Component {
    render() {
        const _a = this.props, { type, symbols } = _a, rest = __rest(_a, ["type", "symbols"]);
        return (React.createElement(AreaSeries, Object.assign({}, rest, { type: "stackedNormalized", symbols: symbols && (React.createElement(CloneElement, Object.assign({ element: symbols }, symbols.props, { point: React.createElement(CloneElement, Object.assign({ element: symbols.props.point }, symbols.props.point.props, { tooltip: null })) }))) })));
    }
}
StackedNormalizedAreaSeries.defaultProps = Object.assign(Object.assign({}, AreaSeries.defaultProps), { type: 'stackedNormalized', tooltip: (React.createElement(TooltipArea, { tooltip: React.createElement(ChartTooltip, { content: (series, color) => {
                if (!series) {
                    return null;
                }
                const value = Object.assign(Object.assign({}, series), { data: series.data.map(d => (Object.assign(Object.assign({}, d), { value: `${formatValue(d.value)}  ${formatValue(Math.floor((d.y1 - d.y0) * 100))}%` }))) });
                return React.createElement(TooltipTemplate, { color: color, value: value });
            } }) })) });

class StackedAreaSeries extends Component {
    render() {
        const _a = this.props, { type, symbols } = _a, rest = __rest(_a, ["type", "symbols"]);
        return (React.createElement(AreaSeries, Object.assign({}, rest, { type: "stacked", symbols: symbols && (React.createElement(CloneElement, Object.assign({ element: symbols }, symbols.props, { point: React.createElement(CloneElement, Object.assign({ element: symbols.props.point }, symbols.props.point.props, { tooltip: null })) }))) })));
    }
}
StackedAreaSeries.defaultProps = Object.assign(Object.assign({}, AreaSeries.defaultProps), { type: 'stacked' });

var css$s = ".AreaChart-module_areaChart__3MZH6 {\n  overflow: visible; }\n";
var css$t = {"areaChart":"AreaChart-module_areaChart__3MZH6"};
styleInject(css$s);

class AreaChart extends Component {
    constructor(props) {
        super(props);
        this.getData = memoize((data, type) => {
            if (type === 'stacked' || type === 'stackedNormalized') {
                return buildStackData(data, type === 'stackedNormalized');
            }
            else if (type === 'grouped') {
                return buildNestedChartData(data, true);
            }
            else {
                return buildShallowChartData(data);
            }
        });
        const zoom = props.zoomPan ? props.zoomPan.props : {};
        const zoomControlled = !zoom.hasOwnProperty('domain');
        this.state = {
            zoomDomain: zoom.domain,
            isZoomed: !!zoom.domain,
            zoomControlled
        };
    }
    static getDerivedStateFromProps(props, state) {
        if (props.zoomPan) {
            const zoom = props.zoomPan.props;
            if (!state.zoomControlled && zoom.domain !== state.zoomDomain) {
                return {
                    zoomDomain: zoom.domain,
                    isZoomed: !!zoom.domain
                };
            }
        }
        return null;
    }
    getScales(data, chartWidth, chartHeight, isMultiSeries) {
        const { zoomDomain } = this.state;
        const { yAxis, xAxis } = this.props;
        const xScale = getXScale({
            width: chartWidth,
            type: xAxis.props.type,
            roundDomains: xAxis.props.roundDomains,
            data,
            domain: zoomDomain || xAxis.props.domain,
            isMultiSeries
        });
        const yScale = getYScale({
            roundDomains: yAxis.props.roundDomains,
            type: yAxis.props.type,
            height: chartHeight,
            data,
            domain: yAxis.props.domain,
            isMultiSeries
        });
        return { xScale, yScale };
    }
    onZoomPan(event) {
        if (this.state.zoomControlled) {
            this.setState({
                zoomDomain: event.domain,
                isZoomed: event.isZoomed,
                preventAnimation: true
            });
            clearTimeout(this.timeout);
            this.timeout = setTimeout(() => this.setState({ preventAnimation: false }), 500);
        }
    }
    renderChart(containerProps) {
        const { chartHeight, chartWidth, id, updateAxes } = containerProps;
        const { series, yAxis, xAxis, gridlines, brush, zoomPan, secondaryAxis } = this.props;
        const { zoomDomain, preventAnimation, isZoomed } = this.state;
        const seriesType = series.props.type;
        const isMultiSeries = seriesType === 'stacked' ||
            seriesType === 'stackedNormalized' ||
            seriesType === 'grouped';
        const data = this.getData(this.props.data, seriesType);
        const { xScale, yScale } = this.getScales(data, chartWidth, chartHeight, isMultiSeries);
        const animated = preventAnimation === true ? false : series.props.animated;
        return (React.createElement(Fragment, null,
            containerProps.chartSized && gridlines && (React.createElement(CloneElement, { element: gridlines, height: chartHeight, width: chartWidth, yScale: yScale, xScale: xScale, yAxis: yAxis.props, xAxis: xAxis.props })),
            React.createElement(CloneElement, { element: xAxis, height: chartHeight, width: chartWidth, scale: xScale, onDimensionsChange: bind(updateAxes, this, 'horizontal') }),
            React.createElement(CloneElement, { element: yAxis, height: chartHeight, width: chartWidth, scale: yScale, onDimensionsChange: bind(updateAxes, this, 'vertical') }),
            secondaryAxis &&
                secondaryAxis.map((axis, i) => (React.createElement(CloneElement, { key: i, element: axis, height: chartHeight, width: chartWidth, onDimensionsChange: bind(updateAxes, this, 'horizontal') }))),
            containerProps.chartSized && (React.createElement(CloneElement, { element: brush, height: chartHeight, width: chartWidth, scale: xScale },
                React.createElement(CloneElement, { element: zoomPan, onZoomPan: bind(this.onZoomPan, this), height: chartHeight, width: chartWidth, axisType: xAxis.props.type, roundDomains: xAxis.props.roundDomains, data: data, domain: zoomDomain },
                    React.createElement(CloneElement, { element: series, id: `area-series-${id}`, data: data, height: chartHeight, width: chartWidth, yScale: yScale, xScale: xScale, isZoomed: isZoomed, animated: animated }))))));
    }
    render() {
        const { xAxis, yAxis, id, width, height, margins, className, series } = this.props;
        return (React.createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: isAxisVisible(xAxis.props), yAxisVisible: isAxisVisible(yAxis.props), className: classNames(css$t.areaChart, className, series.type) }, props => this.renderChart(props)));
    }
}
AreaChart.defaultProps = {
    data: [],
    xAxis: React.createElement(LinearXAxis, { type: "time" }),
    yAxis: React.createElement(LinearYAxis, { type: "value" }),
    series: React.createElement(AreaSeries, null),
    gridlines: React.createElement(GridlineSeries, null),
    brush: null,
    zoomPan: null
};

class StackedAreaChart extends Component {
    render() {
        return React.createElement(AreaChart, Object.assign({}, this.props));
    }
}
StackedAreaChart.defaultProps = {
    series: React.createElement(StackedAreaSeries, null)
};

class StackedNormalizedAreaChart extends Component {
    render() {
        return React.createElement(AreaChart, Object.assign({}, this.props));
    }
}
StackedNormalizedAreaChart.defaultProps = {
    series: React.createElement(StackedNormalizedAreaSeries, null),
    yAxis: (React.createElement(LinearYAxis, { type: "value", tickSeries: React.createElement(LinearYAxisTickSeries, { label: React.createElement(LinearYAxisTickLabel, { rotation: false, format: data => `${data * 100}%` }) }) }))
};

var css$u = ".Bar-module_rounded__1vgiX.Bar-module_vertical__1kQdZ {\n  -webkit-clip-path: inset(0 0 0 0 round 2px 2px 0 0);\n          clip-path: inset(0 0 0 0 round 2px 2px 0 0); }\n\n.Bar-module_rounded__1vgiX.Bar-module_horizontal__h7xo- {\n  -webkit-clip-path: inset(0 0 0 0 round 0 2px 2px 0);\n          clip-path: inset(0 0 0 0 round 0 2px 2px 0); }\n";
var css$v = {"rounded":"Bar-module_rounded__1vgiX","vertical":"Bar-module_vertical__1kQdZ","horizontal":"Bar-module_horizontal__h7xo-"};
styleInject(css$u);

class Bar extends Component {
    constructor() {
        super(...arguments);
        this.state = {};
        this.rect = createRef();
    }
    getExit({ x, y, width, height }) {
        const { yScale, xScale, type } = this.props;
        const isVertical = this.getIsVertical();
        let newX = isVertical ? x : Math.min(...xScale.range());
        let newY = isVertical ? Math.max(...yScale.range()) : y;
        const newHeight = isVertical ? 0 : height;
        const newWidth = isVertical ? width : 0;
        if (type === 'stackedDiverging') {
            if (isVertical) {
                newY = newY / 2;
            }
            else {
                newX = newX / 2;
            }
        }
        return {
            x: newX,
            y: newY,
            height: newHeight,
            width: newWidth
        };
    }
    getKeyCoords(v, v0, v1, scale, sizeOverride, isCategorical, padding) {
        let offset;
        let size;
        if (isCategorical) {
            if (scale.bandwidth) {
                offset = scale(v);
                size = scale.bandwidth();
                if (sizeOverride) {
                    if (offset) {
                        offset = offset + size / 2 - sizeOverride / 2;
                    }
                    else {
                        // Stacked bar charts don't have offsets...
                        offset = size / 2 - sizeOverride / 2;
                    }
                    size = sizeOverride;
                }
            }
            else {
                if (sizeOverride) {
                    throw new Error('Not a valid option for this scale type');
                }
                offset = scale(v0);
                size = scale(v1 - v0);
                if (padding) {
                    const calc = this.calculateLinearScalePadding(scale, offset, size);
                    offset = calc.offset;
                    size = calc.size;
                }
            }
        }
        else {
            if (sizeOverride) {
                throw new Error('Not a valid option for this scale type');
            }
            const c0 = scale(v0);
            const c1 = scale(v1);
            const delta = c1 - c0;
            offset = c0;
            size = Math.max(delta - 1, 0);
        }
        return { offset, size };
    }
    getValueCoords(v0, v1, scale) {
        const c0 = scale(v0);
        const c1 = scale(v1);
        const size = Math.abs(c0 - c1);
        const minSize = Math.max(this.props.minHeight || 0, size);
        return { offset: Math.min(c0, c1), size: minSize };
    }
    getIsVertical() {
        return this.props.layout === 'vertical';
    }
    getCoords(data) {
        const { isCategorical, width, padding, xScale1 } = this.props;
        const isVertical = this.getIsVertical();
        let yScale = this.props.yScale;
        let xScale = this.props.xScale;
        if (xScale1) {
            if (isVertical) {
                xScale = xScale1;
            }
            else {
                yScale = xScale1;
            }
        }
        if (isVertical) {
            const xCoords = this.getKeyCoords(data.x, data.x0, data.x1, xScale, width, isCategorical, padding);
            const yCoords = this.getValueCoords(data.y0, data.y1, yScale);
            return {
                x: xCoords.offset,
                width: xCoords.size,
                y: yCoords.offset,
                height: yCoords.size
            };
        }
        else {
            const yCoords = this.getKeyCoords(data.y, data.y0, data.y1, yScale, width, isCategorical, padding);
            const xCoords = this.getValueCoords(data.x0, data.x1, xScale);
            return {
                x: xCoords.offset,
                width: xCoords.size,
                y: yCoords.offset,
                height: yCoords.size
            };
        }
    }
    /**
     * This function calculates the padding on a linear scale used by the marimekko chart.
     */
    calculateLinearScalePadding(scale, offset, size) {
        const { barCount, groupIndex, padding } = this.props;
        const totalSize = scale.range()[1];
        const sizeMinusPadding = totalSize - padding * (barCount - 1);
        const multiplier = sizeMinusPadding / totalSize;
        offset = offset * multiplier + groupIndex * padding;
        size = size * multiplier;
        return { size, offset };
    }
    onMouseEnter(event) {
        const { onMouseEnter, data, tooltip } = this.props;
        // Only tooltip bars rely on this...
        if (tooltip) {
            this.setState({ active: true });
        }
        onMouseEnter({
            value: data,
            nativeEvent: event
        });
    }
    onMouseLeave(event) {
        const { onMouseLeave, data, tooltip } = this.props;
        // Only tooltip bars rely on this...
        if (tooltip) {
            this.setState({ active: false });
        }
        onMouseLeave({
            value: data,
            nativeEvent: event
        });
    }
    onMouseClick(event) {
        const { onClick, data } = this.props;
        onClick({
            value: data,
            nativeEvent: event
        });
    }
    getFill(color) {
        const { mask, id, gradient } = this.props;
        if (mask) {
            return `url(#mask-pattern-${id})`;
        }
        else {
            if (gradient) {
                return `url(#gradient-${id})`;
            }
            return color;
        }
    }
    getTooltipData() {
        const { data, isCategorical } = this.props;
        const isVertical = this.getIsVertical();
        const xAttr = isCategorical ? 'x' : 'x0';
        let x = data[xAttr];
        // Stacked diverging negative numbers
        // in horizontal layouts need to pull x0
        if (data.x0 < 0) {
            x = data.x0;
        }
        const matches = isVertical
            ? data.key && data.key !== x
            : data.key && data.key !== data.y;
        if (matches) {
            x = `${data.key}  ${x}`;
        }
        return {
            y: data.y,
            x
        };
    }
    getTransition(index) {
        const { animated, barCount, layout } = this.props;
        if (animated) {
            let delay = 0;
            if (layout === 'vertical') {
                delay = (index / barCount) * 0.5;
            }
            else {
                delay = ((barCount - index) / barCount) * 0.5;
            }
            return Object.assign(Object.assign({}, DEFAULT_TRANSITION), { delay: delay });
        }
        else {
            return {
                type: false,
                delay: 0
            };
        }
    }
    renderBar(currentColorShade, coords, index) {
        const { rounded, cursor, mask, id, data, rx, ry, onMouseMove } = this.props;
        const maskPath = mask ? `url(#mask-${id})` : '';
        const fill = this.getFill(currentColorShade);
        const initialExit = this.getExit(coords);
        const isVertical = this.getIsVertical();
        const extras = constructFunctionProps(this.props, data);
        const transition = this.getTransition(index);
        return (React.createElement("g", { ref: this.rect },
            React.createElement(motion.rect, { className: classNames({
                    [css$v.rounded]: rounded,
                    [css$v.vertical]: isVertical,
                    [css$v.horizontal]: !isVertical
                }, extras.className), style: Object.assign(Object.assign({}, extras.style), { cursor }), mask: maskPath, rx: rx, ry: ry, initial: Object.assign(Object.assign({}, initialExit), { fill }), animate: Object.assign(Object.assign({}, coords), { fill }), exit: Object.assign(Object.assign({}, initialExit), { fill }), transition: transition, onMouseEnter: bind(this.onMouseEnter, this), onMouseLeave: bind(this.onMouseLeave, this), onClick: bind(this.onMouseClick, this), onMouseMove: onMouseMove })));
    }
    renderGuideBar() {
        const { data, yScale, active, barIndex, type, guide, xScale } = this.props;
        if (!guide) {
            return null;
        }
        // If we are stacked, only render the first bar
        if (type === 'stacked' && barIndex !== 0) {
            return null;
        }
        // No reason to show them since they are always 100% tall
        if (type === 'stackedNormalized' || type === 'marimekko') {
            console.error('Guide bars are not supported for these chart types');
            return null;
        }
        const vertical = this.getIsVertical();
        const valueScale = vertical ? yScale : xScale;
        const [start, end] = valueScale.domain();
        const attr = vertical ? 'y' : 'x';
        // For stacked diverging we need to flip the points for positive / negative bars
        const attrStart = type === 'stackedDiverging' ? '0' : '1';
        const endPoint = type === 'stackedDiverging' ? start : end;
        const startPoint = type === 'stackedDiverging' && data[attr] > 0 ? end : endPoint;
        const coords = this.getCoords(Object.assign(Object.assign({}, data), { [attr]: endPoint, [`${attr}${attrStart}`]: startPoint }));
        return (React.createElement(CloneElement, Object.assign({ element: guide }, coords, { x: coords.x, width: coords.width, active: active })));
    }
    render() {
        const { activeBrightness, id, gradient, data, barIndex, color, yScale, barCount, xScale, groupIndex, rangeLines, animated, type, tooltip, layout, mask, label } = this.props;
        const active = tooltip ? this.state.active : this.props.active;
        const stroke = color(data, barIndex);
        const coords = this.getCoords(data);
        const currentColorShade = active
            ? chroma(stroke).brighten(activeBrightness).hex()
            : stroke;
        const rangeLineColor = (rangeLines && rangeLines.props.color) || stroke;
        const rangeLineColorShade = active
            ? chroma(rangeLineColor).brighten(activeBrightness)
            : rangeLineColor;
        const index = groupIndex !== undefined ? groupIndex : barIndex;
        const isVertical = this.getIsVertical();
        const scale = isVertical ? yScale : xScale;
        const tooltipData = this.getTooltipData();
        const barLabel = isVertical ? tooltipData.y : tooltipData.x;
        const placement = layout === 'vertical' ? 'top' : 'right';
        return (React.createElement(Fragment, null,
            this.renderGuideBar(),
            this.renderBar(currentColorShade, coords, index),
            rangeLines && (React.createElement(CloneElement, Object.assign({ element: rangeLines }, coords, { index: index, data: data, scale: scale, color: rangeLineColorShade, barCount: barCount, animated: animated, layout: layout, type: type }))),
            mask && (React.createElement(Fragment, null,
                React.createElement(Mask, { id: `mask-${id}`, fill: `url(#gradient-${id})` }),
                React.createElement(CloneElement, { element: mask, id: `mask-pattern-${id}`, fill: stroke }))),
            gradient && (React.createElement(CloneElement, { element: gradient, id: `gradient-${id}`, direction: layout, color: currentColorShade })),
            label && (React.createElement(CloneElement, Object.assign({ element: label }, coords, { text: formatValue(barLabel), index: index, data: data, scale: scale, fill: label.props.fill || currentColorShade, barCount: barCount, animated: animated, layout: layout, type: type }))),
            tooltip && (React.createElement(CloneElement, { element: tooltip, visible: !!active, reference: this.rect, color: color, value: tooltipData, placement: tooltip.props.placement || placement, data: data }))));
    }
}
Bar.defaultProps = {
    activeBrightness: 0.5,
    rounded: true,
    rx: 0,
    ry: 0,
    cursor: 'auto',
    rangeLines: null,
    label: null,
    tooltip: null,
    layout: 'vertical',
    guide: null,
    gradient: React.createElement(Gradient, null),
    onClick: () => undefined,
    onMouseEnter: () => undefined,
    onMouseLeave: () => undefined,
    onMouseMove: () => undefined
};

class BarSeries extends Component {
    constructor() {
        super(...arguments);
        this.state = {};
        this.ref = createRef();
    }
    getIsMulti() {
        const { type } = this.props;
        return (type === 'grouped' ||
            type === 'stacked' ||
            type === 'marimekko' ||
            type === 'stackedNormalized' ||
            type === 'stackedDiverging');
    }
    /**
     * Get the translation for the bar group.
     */
    getTransform(data) {
        const { xScale, yScale, type, layout } = this.props;
        let xPos = 0;
        let yPos = 0;
        if (type !== 'marimekko') {
            if (layout === 'vertical') {
                const val = xScale(data.key);
                xPos = val;
            }
            else {
                const val = yScale(data.key);
                yPos = val;
            }
        }
        return `translate(${xPos}, ${yPos})`;
    }
    getColor(point, index) {
        const { colorScheme, data, layout } = this.props;
        const isMultiSeries = this.getIsMulti();
        let key = 'key';
        if (isMultiSeries) {
            if (layout === 'vertical') {
                key = 'x';
            }
            else {
                key = 'y';
            }
        }
        // histograms...
        if (point[key] === undefined) {
            key = 'x0';
        }
        return getColor({
            colorScheme,
            point,
            index,
            data,
            isMultiSeries,
            attribute: key
        });
    }
    onMouseMove(event) {
        var _a;
        // Manuallly call mouse move so we don't have to kill bar pointer events
        (_a = this.ref.current) === null || _a === void 0 ? void 0 : _a.onMouseMove(event);
    }
    renderBar(data, barIndex, barCount, groupIndex) {
        const { xScale1, bar, padding, animated, isCategorical, layout, type, id } = this.props;
        const { activeValues } = this.state;
        const active = activeValues && activeValues.x === data.key;
        const isVertical = layout === 'vertical';
        let yScale = this.props.yScale;
        let xScale = this.props.xScale;
        if (xScale1) {
            if (isVertical) {
                xScale = xScale1;
            }
            else {
                yScale = xScale1;
            }
        }
        // Histograms dont have keys
        let key = barIndex.toString();
        if (data.key) {
            key = `${data.key.toString()}-${groupIndex}-${barIndex}`;
        }
        let barElements = Array.isArray(bar) ? bar[barIndex] : bar;
        if (!bar) {
            barElements = React.createElement(Bar, null);
        }
        return (React.createElement(Fragment, { key: key },
            React.createElement(CloneElement, { element: barElements, id: `${id}-bar-${groupIndex}-${barIndex}`, animated: animated, active: active, xScale: xScale, xScale1: xScale1, yScale: yScale, padding: padding, barCount: barCount, groupIndex: groupIndex, barIndex: barIndex, data: data, isCategorical: isCategorical, color: this.getColor.bind(this), layout: layout, type: type, onMouseMove: this.onMouseMove.bind(this) })));
    }
    /**
     * Get the bar group.
     */
    renderBarGroup(data, barCount, groupIndex) {
        return (React.createElement(Fragment, null, data.map((barData, barIndex) => this.renderBar(barData, barIndex, barCount, groupIndex))));
    }
    onValueEnter(event) {
        this.setState({
            activeValues: event.value
        });
    }
    onValueLeave() {
        this.setState({
            activeValues: undefined
        });
    }
    render() {
        const { data, tooltip, xScale, yScale, height, width, layout } = this.props;
        const isMulti = this.getIsMulti();
        return (React.createElement(CloneElement, { element: tooltip, childRef: this.ref, xScale: xScale, yScale: yScale, data: data, height: height, width: width, inverse: false, isHorizontal: layout === 'horizontal', color: this.getColor.bind(this), onValueEnter: this.onValueEnter.bind(this), onValueLeave: this.onValueLeave.bind(this) },
            isMulti &&
                data.map((groupData, index) => (React.createElement("g", { transform: this.getTransform(groupData), key: `bar-group-${index}` }, this.renderBarGroup(groupData.data, data.length, index)))),
            !isMulti &&
                this.renderBarGroup(data, data.length)));
    }
}
BarSeries.defaultProps = {
    type: 'standard',
    padding: 0.1,
    groupPadding: 16,
    animated: true,
    tooltip: (React.createElement(TooltipArea, { tooltip: React.createElement(ChartTooltip, { followCursor: true, modifiers: {
                offset: '5px, 5px'
            } }) })),
    colorScheme: 'cybertron',
    bar: React.createElement(Bar, null),
    layout: 'vertical'
};

class RangeLines extends Component {
    getIsVertical() {
        return this.props.layout === 'vertical';
    }
    getEnter(rangeLineHeight) {
        const { x, y, height, position, width, data } = this.props;
        const isVertical = this.getIsVertical();
        let newY = y;
        let newX = x;
        // If its diverging and the value is negative, we
        // need to reverse the type...
        const isTop = position === 'top';
        const direction = isVertical
            ? data.y < 0 && isTop
                ? 'bottom'
                : position
            : data.x0 < 0 && isTop
                ? 'bottom'
                : position;
        if (isVertical) {
            if (direction === 'top') {
                newY = y;
            }
            else {
                newY = y + height - rangeLineHeight;
            }
        }
        else {
            if (direction === 'top') {
                newX = x + width - rangeLineHeight;
            }
            else {
                newX = x;
            }
        }
        return {
            x: newX,
            y: newY,
            opacity: 1
        };
    }
    getExit(rangeLineHeight) {
        const { x, scale, height, width, y, position, type } = this.props;
        const isVertical = this.getIsVertical();
        let newY = y;
        let newX = x;
        if (isVertical) {
            const maxY = Math.max(...scale.range());
            if (position === 'top') {
                newY = maxY;
            }
            else {
                newY = maxY + height - rangeLineHeight;
            }
        }
        else {
            const minX = Math.min(...scale.range());
            if (position === 'top') {
                newX = minX;
            }
            else {
                newX = minX + width - rangeLineHeight;
            }
        }
        if (type === 'stackedDiverging') {
            if (isVertical) {
                newY = newY / 2;
            }
            else {
                newX = newX / 2;
            }
        }
        return {
            y: newY,
            x: newX,
            opacity: 0
        };
    }
    getLineHeight() {
        const { height, width, strokeWidth } = this.props;
        const isVertical = this.getIsVertical();
        return Math.min(strokeWidth, isVertical ? height : width);
    }
    getHeightWidth(rangeLineHeight) {
        const { height, width } = this.props;
        const isVertical = this.getIsVertical();
        return {
            width: isVertical ? width : rangeLineHeight,
            height: isVertical ? rangeLineHeight : height
        };
    }
    getDelay() {
        const { animated, index, barCount, layout } = this.props;
        let delay = 0;
        if (animated) {
            if (layout === 'vertical') {
                return (index / barCount) * 0.5;
            }
            else {
                return ((barCount - index) / barCount) * 0.5;
            }
        }
        return delay;
    }
    render() {
        const { color } = this.props;
        const rangeLineHeight = this.getLineHeight();
        const enterProps = this.getEnter(rangeLineHeight);
        const exitProps = this.getExit(rangeLineHeight);
        const { height, width } = this.getHeightWidth(rangeLineHeight);
        const delay = this.getDelay();
        return (React.createElement(motion.rect, { pointerEvents: "none", fill: color, width: width, height: height, initial: exitProps, animate: enterProps, exit: exitProps, transition: Object.assign(Object.assign({}, DEFAULT_TRANSITION), { delay }) }));
    }
}
RangeLines.defaultProps = {
    position: 'top',
    strokeWidth: 1,
    layout: 'vertical'
};

class StackedBarSeries extends Component {
    render() {
        const _a = this.props, { type } = _a, rest = __rest(_a, ["type"]);
        return React.createElement(BarSeries, Object.assign({ type: type }, rest));
    }
}
StackedBarSeries.defaultProps = Object.assign(Object.assign({}, BarSeries.defaultProps), { type: 'stacked', bar: (React.createElement(Bar, { rounded: false, gradient: React.createElement(Gradient, { stops: [
                React.createElement(GradientStop, { offset: "5%", stopOpacity: 0.1, key: "start" }),
                React.createElement(GradientStop, { offset: "90%", stopOpacity: 0.7, key: "stop" })
            ] }), rangeLines: React.createElement(RangeLines, { position: "top", strokeWidth: 3 }) })) });

class StackedNormalizedBarSeries extends Component {
    render() {
        const _a = this.props, rest = __rest(_a, ["type"]);
        return React.createElement(BarSeries, Object.assign({ type: "stackedNormalized" }, rest));
    }
}
StackedNormalizedBarSeries.defaultProps = Object.assign(Object.assign({}, BarSeries.defaultProps), { type: 'stackedNormalized', tooltip: (React.createElement(TooltipArea, { tooltip: React.createElement(ChartTooltip, { followCursor: true, modifiers: {
                offset: '5px, 5px'
            }, content: (point, color) => {
                point.data = point.data.map(d => {
                    // Handle horz case
                    const start = isNaN(d.y0) ? d.x0 : d.y0;
                    const end = isNaN(d.y1) ? d.x1 : d.y1;
                    return Object.assign(Object.assign({}, d), { value: `${formatValue(Math.floor((end - start) * 100))}%` });
                });
                return React.createElement(TooltipTemplate, { value: point, color: color });
            } }) })), bar: (React.createElement(Bar, { rounded: false, gradient: React.createElement(Gradient, { stops: [
                React.createElement(GradientStop, { offset: "5%", stopOpacity: 0.1, key: "start" }),
                React.createElement(GradientStop, { offset: "90%", stopOpacity: 0.7, key: "stop" })
            ] }), rangeLines: React.createElement(RangeLines, { position: "top", strokeWidth: 3 }) })) });

class MarimekkoBarSeries extends Component {
    render() {
        const _a = this.props, rest = __rest(_a, ["type"]);
        return React.createElement(BarSeries, Object.assign({ type: "marimekko" }, rest));
    }
}
MarimekkoBarSeries.defaultProps = Object.assign(Object.assign({}, BarSeries.defaultProps), { type: 'marimekko', padding: 10, tooltip: (React.createElement(TooltipArea, { tooltip: React.createElement(ChartTooltip, { followCursor: true, modifiers: {
                offset: '5px, 5px'
            }, content: (point, color) => {
                const data = Object.assign(Object.assign({}, point), { data: point.data.map(d => (Object.assign(Object.assign({}, d), { value: `${formatValue(d.value)}  ${formatValue(Math.floor((d.y1 - d.y0) * 100))}%` }))) });
                return React.createElement(TooltipTemplate, { value: data, color: color });
            } }) })), bar: (React.createElement(Bar, { rounded: false, padding: 10, gradient: React.createElement(Gradient, { stops: [
                React.createElement(GradientStop, { offset: "5%", stopOpacity: 0.1, key: "start" }),
                React.createElement(GradientStop, { offset: "90%", stopOpacity: 0.7, key: "stop" })
            ] }), rangeLines: React.createElement(RangeLines, { position: "top", strokeWidth: 3 }) })) });

class BarLabel extends PureComponent {
    getIsVertical() {
        return this.props.layout === 'vertical';
    }
    getEnter() {
        const { x, y, height, position, width, data, padding } = this.props;
        const isVertical = this.getIsVertical();
        let newY = y;
        let newX = x;
        // If its diverging and the value is negative, we
        // need to reverse the type...
        const isTop = position === 'top';
        const direction = isVertical
            ? data.y < 0 && isTop
                ? 'bottom'
                : position
            : data.x0 < 0 && isTop
                ? 'bottom'
                : position;
        if (isVertical) {
            if (direction === 'top') {
                newY = y - padding;
            }
            else if (direction === 'center') {
                newY = y + height / 2;
            }
            else if (direction === 'bottom') {
                newY = y + height - padding;
            }
            newX = newX + width / 2;
        }
        else {
            if (direction === 'top') {
                newX = x + width + padding;
            }
            else if (direction === 'center') {
                newX = x + width / 2;
            }
            else if (direction === 'bottom') {
                newX = x + padding;
            }
            newY = newY + height / 2;
        }
        return {
            translateX: newX,
            translateY: newY,
            opacity: 1
        };
    }
    getExit() {
        const { x, scale, height, width, y, position, type, padding } = this.props;
        const isVertical = this.getIsVertical();
        let newY = y;
        let newX = x;
        if (isVertical) {
            const maxY = Math.max(...scale.range());
            if (position === 'top') {
                newY = maxY;
            }
            else {
                newY = maxY + height + padding;
            }
            newX = newX + width / 2;
        }
        else {
            const minX = Math.min(...scale.range());
            if (position === 'top') {
                newX = minX;
            }
            else {
                newX = minX + width + padding;
            }
            newY = newY + height / 2;
        }
        if (type === 'stackedDiverging') {
            if (isVertical) {
                newY = newY / 2;
            }
            else {
                newX = newX / 2;
            }
        }
        return {
            translateY: newY,
            translateX: newX,
            opacity: 0
        };
    }
    getDelay() {
        const { animated, index, barCount, layout } = this.props;
        let delay = 0;
        if (animated) {
            if (layout === 'vertical') {
                return (index / barCount) * 0.5;
            }
            else {
                return ((barCount - index) / barCount) * 0.5;
            }
        }
        return delay;
    }
    render() {
        const { fontSize, fontFamily, fill, className, text } = this.props;
        const enterProps = this.getEnter();
        const exitProps = this.getExit();
        const delay = this.getDelay();
        const textAnchor = this.getIsVertical() ? 'middle' : 'start';
        return (React.createElement(motion.g, { initial: exitProps, animate: enterProps, exit: exitProps, transition: Object.assign(Object.assign({}, DEFAULT_TRANSITION), { delay }), fontSize: fontSize, fontFamily: fontFamily },
            React.createElement("text", { fill: fill, className: className, textAnchor: textAnchor }, text)));
    }
}
BarLabel.defaultProps = {
    position: 'top',
    layout: 'vertical',
    fontSize: 13,
    padding: 5,
    fontFamily: 'sans-serif',
    fill: '#000'
};

class HistogramBarSeries extends Component {
    render() {
        const _a = this.props, rest = __rest(_a, ["type"]);
        return React.createElement(BarSeries, Object.assign({}, rest));
    }
}
HistogramBarSeries.defaultProps = Object.assign(Object.assign({}, BarSeries.defaultProps), { colorScheme: schemes.cybertron[0], tooltip: (React.createElement(TooltipArea, { tooltip: React.createElement(ChartTooltip, { followCursor: true, modifiers: {
                offset: '5px, 5px'
            }, content: (point, color) => {
                const data = Object.assign(Object.assign({}, point), { x: `${formatValue(point.x0)} - ${formatValue(point.x1)}`, value: point.y });
                return React.createElement(TooltipTemplate, { value: data, color: color });
            } }) })) });

const GuideBar = (_a) => {
    var { active, fill = '#eee', opacity = 0.15 } = _a, rest = __rest(_a, ["active", "fill", "opacity"]);
    return (React.createElement(motion.rect, Object.assign({}, rest, { fill: fill, pointerEvents: "none", initial: "hidden", animate: active ? 'visible' : 'hidden', variants: {
            hidden: { opacity: 0 },
            visible: { opacity }
        } })));
};

var css$w = ".BarChart-module_barChart__1TypA {\n  overflow: visible; }\n  .BarChart-module_barChart__1TypA.BarChart-module_stackedNormalized__2uegt .bar, .BarChart-module_barChart__1TypA.BarChart-module_stacked__3ZLYq .bar, .BarChart-module_barChart__1TypA.BarChart-module_marimekko__-hOhA .bar {\n    stroke: var(--color-background);\n    stroke-width: 0.2; }\n";
var css$x = {"barChart":"BarChart-module_barChart__1TypA","stackedNormalized":"BarChart-module_stackedNormalized__2uegt","stacked":"BarChart-module_stacked__3ZLYq","marimekko":"BarChart-module_marimekko__-hOhA"};
styleInject(css$w);

class BarChart extends Component {
    getScalesAndData(chartHeight, chartWidth) {
        const { yAxis, xAxis, series } = this.props;
        const { type, layout } = series.props;
        const isVertical = this.getIsVertical();
        const isMarimekko = type === 'marimekko';
        const isGrouped = type === 'grouped';
        const isStacked = type === 'stacked' ||
            type === 'stackedNormalized' ||
            type === 'stackedDiverging';
        const isMultiSeries = isGrouped || isStacked;
        let data;
        if (isStacked) {
            let distroType = 'default';
            if (type === 'stackedNormalized') {
                distroType = 'expand';
            }
            else if (type === 'stackedDiverging') {
                distroType = 'diverging';
            }
            data = buildBarStackData(this.props.data, distroType, layout);
        }
        else if (type === 'waterfall') {
            data = buildWaterfall(this.props.data, layout, this.props.series.props.binSize);
        }
        else if (isMarimekko) {
            data = buildMarimekkoData(this.props.data);
        }
        else if (isGrouped) {
            data = buildNestedChartData(this.props.data, false, layout);
        }
        else {
            data = buildShallowChartData(this.props.data, layout, this.props.series.props.binSize);
        }
        let yScale;
        let xScale;
        let xScale1;
        if (isVertical) {
            if (isGrouped) {
                const { keyScale, groupScale } = this.getMultiGroupScales(data, chartHeight, chartWidth);
                xScale = groupScale;
                xScale1 = keyScale;
            }
            else if (isMarimekko) {
                const { keyScale, groupScale } = this.getMarimekkoGroupScales(data, xAxis, chartWidth);
                xScale = groupScale;
                xScale1 = keyScale;
            }
            else {
                xScale = this.getKeyScale(data, xAxis, isMultiSeries, chartWidth);
            }
            yScale = this.getValueScale(data, yAxis, isMultiSeries, chartHeight);
        }
        else {
            if (isGrouped) {
                const { keyScale, groupScale } = this.getMultiGroupScales(data, chartHeight, chartWidth);
                yScale = groupScale;
                xScale1 = keyScale;
                xScale = this.getKeyScale(data, xAxis, isMultiSeries, chartWidth);
            }
            else if (isMarimekko) {
                throw new Error('Marimekko is currently not supported for horizontal layouts');
            }
            else {
                xScale = this.getKeyScale(data, xAxis, isMultiSeries, chartWidth);
                yScale = this.getValueScale(data, yAxis, isMultiSeries, chartHeight);
            }
        }
        // data = this.getBinnedData(data, xScale, yScale);
        return { xScale, xScale1, yScale, data };
    }
    getKeyAxis() {
        const { yAxis, xAxis } = this.props;
        const isVertical = this.getIsVertical();
        return isVertical ? xAxis : yAxis;
    }
    getIsDiverging() {
        return this.props.series.props.type === 'stackedDiverging';
    }
    getIsVertical() {
        return this.props.series.props.layout === 'vertical';
    }
    getMarimekkoGroupScales(data, axis, width) {
        const { series } = this.props;
        const keyScale = getMarimekkoScale(width, axis.props.roundDomains);
        const groupScale = getMarimekkoGroupScale({
            width,
            padding: series.props.padding,
            data,
            valueScale: keyScale
        });
        return {
            keyScale,
            groupScale
        };
    }
    getMultiGroupScales(data, height, width) {
        const { series } = this.props;
        const isVertical = this.getIsVertical();
        const { groupPadding, layout } = series.props;
        const groupScale = getGroupScale({
            dimension: isVertical ? width : height,
            direction: layout,
            padding: groupPadding,
            data
        });
        const keyScale = getInnerScale({
            groupScale: groupScale,
            padding: series.props.padding,
            data,
            prop: isVertical ? 'x' : 'y'
        });
        return {
            groupScale,
            keyScale
        };
    }
    getKeyScale(data, axis, isMultiSeries, width) {
        const { series } = this.props;
        return getXScale({
            width,
            type: axis.props.type,
            roundDomains: axis.props.roundDomains,
            data,
            padding: series.props.padding,
            domain: axis.props.domain,
            isMultiSeries,
            isDiverging: this.getIsDiverging()
        });
    }
    getValueScale(data, axis, isMultiSeries, height) {
        const { series } = this.props;
        return getYScale({
            roundDomains: axis.props.roundDomains,
            padding: series.props.padding,
            type: axis.props.type,
            height,
            data,
            domain: axis.props.domain,
            isMultiSeries,
            isDiverging: this.getIsDiverging()
        });
    }
    renderChart(containerProps) {
        const { chartHeight, chartWidth, id, updateAxes } = containerProps;
        const { series, xAxis, yAxis, brush, gridlines, secondaryAxis } = this.props;
        const { xScale, xScale1, yScale, data } = this.getScalesAndData(chartHeight, chartWidth);
        const isVertical = this.getIsVertical();
        const keyAxis = this.getKeyAxis();
        const isCategorical = keyAxis.props.type === 'category';
        return (React.createElement(Fragment, null,
            containerProps.chartSized && gridlines && (React.createElement(CloneElement, { element: gridlines, height: chartHeight, width: chartWidth, yScale: yScale, xScale: xScale, yAxis: yAxis.props, xAxis: xAxis.props })),
            React.createElement(CloneElement, { element: xAxis, height: chartHeight, width: chartWidth, scale: xScale, onDimensionsChange: bind(updateAxes, this, isVertical ? 'horizontal' : 'vertical') }),
            React.createElement(CloneElement, { element: yAxis, height: chartHeight, width: chartWidth, scale: yScale, onDimensionsChange: bind(updateAxes, this, isVertical ? 'vertical' : 'horizontal') }),
            secondaryAxis &&
                secondaryAxis.map((axis, i) => (React.createElement(CloneElement, { key: i, element: axis, height: chartHeight, width: chartWidth, onDimensionsChange: bind(updateAxes, this, 'horizontal') }))),
            containerProps.chartSized && (React.createElement(CloneElement, { element: brush, height: chartHeight, width: chartWidth, scale: xScale },
                React.createElement(CloneElement, { element: series, id: `bar-series-${id}`, data: data, height: chartHeight, width: chartWidth, isCategorical: isCategorical, xScale: xScale, xScale1: xScale1, yScale: yScale })))));
    }
    render() {
        const { id, width, height, margins, className, series, xAxis, yAxis } = this.props;
        return (React.createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: isAxisVisible(xAxis.props), yAxisVisible: isAxisVisible(yAxis.props), className: classNames(css$x.barChart, className, css$x[series.props.type]) }, props => this.renderChart(props)));
    }
}
BarChart.defaultProps = {
    data: [],
    xAxis: (React.createElement(LinearXAxis, { type: "category", tickSeries: React.createElement(LinearXAxisTickSeries, { tickSize: 20 }) })),
    yAxis: React.createElement(LinearYAxis, { type: "value" }),
    series: React.createElement(BarSeries, null),
    gridlines: React.createElement(GridlineSeries, null),
    brush: null
};

const MarimekkoChart = (_a) => {
    var { series = React.createElement(MarimekkoBarSeries, null), xAxis = (React.createElement(LinearXAxis, { type: "category", tickSeries: React.createElement(LinearXAxisTickSeries, { tickSize: 15 }) })), yAxis = (React.createElement(LinearYAxis, { type: "value", tickSeries: React.createElement(LinearYAxisTickSeries, { label: React.createElement(LinearYAxisTickLabel, { rotation: false, format: data => `${data * 100}%` }) }) })) } = _a, rest = __rest(_a, ["series", "xAxis", "yAxis"]);
    return React.createElement(BarChart, Object.assign({}, rest, { series: series, xAxis: xAxis, yAxis: yAxis }));
};

const StackedBarChart = (_a) => {
    var { series = React.createElement(StackedBarSeries, null) } = _a, rest = __rest(_a, ["series"]);
    return React.createElement(BarChart, Object.assign({}, rest, { series: series }));
};

const StackedNormalizedBarChart = (_a) => {
    var { series = React.createElement(StackedNormalizedBarSeries, null), yAxis = (React.createElement(LinearYAxis, { type: "value", tickSeries: React.createElement(LinearYAxisTickSeries, { label: React.createElement(LinearYAxisTickLabel, { rotation: false, format: data => `${data * 100}%` }) }) })) } = _a, rest = __rest(_a, ["series", "yAxis"]);
    return React.createElement(BarChart, Object.assign({}, rest, { series: series, yAxis: yAxis }));
};

const HistogramBarChart = (_a) => {
    var { series = React.createElement(HistogramBarSeries, null) } = _a, rest = __rest(_a, ["series"]);
    return React.createElement(BarChart, Object.assign({}, rest, { series: series }));
};

var css$y = ".HiveNode-module_node__3erj2 {\n  -webkit-transition: opacity 100ms ease-in-out;\n  transition: opacity 100ms ease-in-out;\n  cursor: pointer; }\n\n.HiveNode-module_inactive__3qXzC {\n  opacity: 0.2; }\n";
var css$z = {"node":"HiveNode-module_node__3erj2","inactive":"HiveNode-module_inactive__3qXzC"};
styleInject(css$y);

class HiveNode extends Component {
    render() {
        const { angle, radius, node, color, onClick, onMouseOver, onMouseOut, active, disabled } = this.props;
        // If the size exists on the node, use it to specify the node size.
        // Otherwise, calculate a relative size using the node count.
        let size = node.size;
        if (size === undefined) {
            size = node.count || 0;
        }
        return (React.createElement("circle", { className: classNames(css$z.node, {
                [css$z.inactive]: !active
            }), transform: `rotate(${getDegrees(angle(node.x))})`, cx: radius(node.y), r: size, style: { cursor: disabled ? 'initial' : 'cursor' }, fill: color(node.x), onClick: onClick, onMouseOver: onMouseOver, onMouseOut: onMouseOut }));
    }
}

var css$A = ".HiveAxis-module_axis__30gBf {\n  stroke: #575f67;\n  stroke-width: 1.5px; }\n";
var css$B = {"axis":"HiveAxis-module_axis__30gBf"};
styleInject(css$A);

class HiveAxis extends Component {
    render() {
        const { radius, index, angle, color } = this.props;
        const [axisStart, axisEnd] = radius.range();
        const axisLength = axisEnd - axisStart;
        return (React.createElement(Fragment, null,
            React.createElement("line", { className: css$B.axis, style: { stroke: color(index) }, transform: `rotate(${getDegrees(angle(index))})`, x1: axisStart, x2: axisEnd }),
            React.createElement("line", { className: css$B.axis, style: { stroke: color(index) }, transform: `rotate(${getDegrees(angle(index)) + 90})`, x1: -axisLength / 20, x2: axisLength / 20, y1: -axisEnd, y2: -axisEnd }),
            React.createElement("line", { className: css$B.axis, style: { stroke: color(index) }, transform: `rotate(${getDegrees(angle(index)) + 90})`, x1: -axisStart / 3, x2: 0, y1: axisStart * -0.8, y2: axisStart * -1 }),
            React.createElement("line", { className: css$B.axis, style: { stroke: color(index) }, transform: `rotate(${getDegrees(angle(index)) + 90})`, x1: 0, x2: axisStart / 3, y1: -axisStart, y2: axisStart * -0.8 })));
    }
}

/**
 * Hive layout
 * Original: https://github.com/d3/d3-plugins/tree/master/hive
 */
function hiveLayout() {
    let source = d => d.source;
    let target = d => d.target;
    let angle = d => d.angle;
    let startRadius = d => d.radius;
    let endRadius = startRadius;
    const arcOffset = -Math.PI / 2;
    const link = (d, i) => {
        let s = node(source, this, d, i);
        let t = node(target, this, d, i);
        let x;
        if (t.a < s.a) {
            x = t;
            t = s;
            s = x;
        }
        if (t.a - s.a > Math.PI) {
            s.a += 2 * Math.PI;
        }
        const a1 = s.a + (t.a - s.a) / 3;
        const a2 = t.a - (t.a - s.a) / 3;
        return s.r0 - s.r1 || t.r0 - t.r1
            ? 'M' +
                Math.cos(s.a) * s.r0 +
                ',' +
                Math.sin(s.a) * s.r0 +
                'L' +
                Math.cos(s.a) * s.r1 +
                ',' +
                Math.sin(s.a) * s.r1 +
                'C' +
                Math.cos(a1) * s.r1 +
                ',' +
                Math.sin(a1) * s.r1 +
                ' ' +
                Math.cos(a2) * t.r1 +
                ',' +
                Math.sin(a2) * t.r1 +
                ' ' +
                Math.cos(t.a) * t.r1 +
                ',' +
                Math.sin(t.a) * t.r1 +
                'L' +
                Math.cos(t.a) * t.r0 +
                ',' +
                Math.sin(t.a) * t.r0 +
                'C' +
                Math.cos(a2) * t.r0 +
                ',' +
                Math.sin(a2) * t.r0 +
                ' ' +
                Math.cos(a1) * s.r0 +
                ',' +
                Math.sin(a1) * s.r0 +
                ' ' +
                Math.cos(s.a) * s.r0 +
                ',' +
                Math.sin(s.a) * s.r0
            : 'M' +
                Math.cos(s.a) * s.r0 +
                ',' +
                Math.sin(s.a) * s.r0 +
                'C' +
                Math.cos(a1) * s.r1 +
                ',' +
                Math.sin(a1) * s.r1 +
                ' ' +
                Math.cos(a2) * t.r1 +
                ',' +
                Math.sin(a2) * t.r1 +
                ' ' +
                Math.cos(t.a) * t.r1 +
                ',' +
                Math.sin(t.a) * t.r1;
    };
    const node = (method, thiz, d, i) => {
        const n = method.call(thiz, d, i);
        const a = +(typeof angle === 'function' ? angle.call(thiz, n, i) : angle) +
            arcOffset;
        const r0 = +(typeof startRadius === 'function'
            ? startRadius.call(thiz, n, i)
            : startRadius);
        const r1 = startRadius === endRadius
            ? r0
            : +(typeof endRadius === 'function'
                ? endRadius.call(thiz, n, i)
                : endRadius);
        return { r0, r1, a };
    };
    link.source = s => {
        if (!s) {
            return source;
        }
        source = s;
        return link;
    };
    link.target = t => {
        if (!t) {
            return target;
        }
        target = t;
        return link;
    };
    link.angle = a => {
        if (!a) {
            return angle;
        }
        angle = a;
        return link;
    };
    link.radius = r => {
        if (!r) {
            return startRadius;
        }
        startRadius = endRadius = r;
        return link;
    };
    link.startRadius = r => {
        if (!r) {
            return startRadius;
        }
        startRadius = r;
        return link;
    };
    link.endRadius = r => {
        if (!r) {
            return endRadius;
        }
        endRadius = r;
        return link;
    };
    return link;
}

var css$C = ".HiveLink-module_link__3c55e {\n  fill: none;\n  stroke-width: 1.5px;\n  stroke-opacity: 0.5;\n  -webkit-transition: opacity 100ms ease-in-out;\n  transition: opacity 100ms ease-in-out; }\n\n.HiveLink-module_inactive__3ZmVV {\n  opacity: 0.7; }\n";
var css$D = {"link":"HiveLink-module_link__3c55e","inactive":"HiveLink-module_inactive__3ZmVV"};
styleInject(css$C);

class HiveLink extends Component {
    prepareData() {
        const { angle, radius } = this.props;
        const hive = hiveLayout();
        return {
            angle: hive.angle(d => angle(d.x)),
            radius: hive.radius(d => radius(d.y))
        };
    }
    render() {
        const { link, color, active, onMouseOver, onMouseOut } = this.props;
        const { angle, radius } = this.prepareData();
        const stroke = typeof color === 'string' ? color : color(link.source.x);
        return (React.createElement("path", { className: classNames(css$D.link, {
                [css$D.inactive]: !active
            }), d: `${angle(link)} ${radius(link)}`, stroke: stroke, onMouseOver: onMouseOver, onMouseOut: onMouseOut }));
    }
}

var css$E = ".HiveLabel-module_label__1tbC6 {\n  fill: rgba(255, 255, 255, 0.5);\n  font-size: 12px;\n  text-transform: uppercase; }\n";
var css$F = {"label":"HiveLabel-module_label__1tbC6"};
styleInject(css$E);

const degrees = (radians) => {
    const res = (radians / Math.PI) * 180;
    return res > 90 ? res + 180 : res;
};
const translate = (d, outerRadius, padding) => d > 90 ? outerRadius + 8 + padding : -(outerRadius + padding);
class HiveLabel extends Component {
    render() {
        const { index, text, angle, outerRadius, label } = this.props;
        const transform = degrees(angle(index));
        return (React.createElement("text", { dy: translate(transform, outerRadius, label.padding), className: css$F.label, strokeWidth: "0.01", textAnchor: "middle", transform: `rotate(${transform})` }, text));
    }
}

var css$G = ".HiveTooltip-module_label__1gfVp {\n  font-size: 16px;\n  margin-bottom: 3px; }\n\n.HiveTooltip-module_value__36Qwn {\n  font-size: 13px;\n  color: rgba(255, 255, 255, 0.7); }\n";
var css$H = {"label":"HiveTooltip-module_label__1gfVp","value":"HiveTooltip-module_value__36Qwn"};
styleInject(css$G);

class HiveTooltip extends Component {
    render() {
        const { axis, nodes, node: { x, value } } = this.props;
        const { label } = axis[x];
        const count = nodes.filter(n => n.value === value).length;
        return (React.createElement("div", null,
            React.createElement("div", { className: css$H.label },
                label,
                " - ",
                formatValue(value)),
            React.createElement("div", { className: css$H.value },
                formatValue(count),
                " Total")));
    }
}

class HivePlot extends Component {
    constructor() {
        super(...arguments);
        this.state = {};
    }
    onNodeMouseOver(node, event) {
        const { links, nodes, onNodeMouseOver, disabled } = this.props;
        if (!disabled) {
            const activeNodeIndex = nodes.indexOf(node);
            const activeNodes = {};
            for (const link of links) {
                const { source, target } = link;
                if (source.value === node.value || target.value === node.value) {
                    const next = target.value === node.value ? source : target;
                    const idx = nodes.indexOf(next);
                    activeNodes[`node-${idx}`] = true;
                }
            }
            this.setState({
                tooltipReference: event.target,
                nodeTooltipData: node,
                active: Object.assign(Object.assign({ [`node-${activeNodeIndex}`]: true }, activeNodes), links.reduce((accumulator, link, i) => {
                    if (link.source.value === node.value ||
                        link.target.value === node.value) {
                        accumulator[`link-${i}`] = true;
                    }
                    return accumulator;
                }, {}))
            });
        }
        onNodeMouseOver({
            nativeEvent: event,
            node,
            links: this.getLinksForNode(node)
        });
    }
    onLinkMouseOver(link, event) {
        const { onLinkMouseOver, disabled } = this.props;
        if (!disabled) {
            this.setState({
                tooltipReference: event.target,
                linkTooltipData: link
            });
            this.activateLink(link);
        }
        onLinkMouseOver({
            nativeEvent: event,
            link
        });
    }
    activateLink(link) {
        const { nodes, links } = this.props;
        const activeLinkIndex = links.indexOf(link);
        const activeLinksMap = {
            [`link-${activeLinkIndex}`]: true
        };
        const activeLinks = [
            link,
            ...this.activateAdjacentLinks(links, link.target, activeLinksMap)
        ];
        this.setState({
            active: Object.assign(Object.assign({}, activeLinksMap), nodes.reduce((accumulator, node, i) => {
                for (const activeLink of activeLinks) {
                    const { source, target } = activeLink;
                    if (node === source || node === target) {
                        accumulator[`node-${i}`] = true;
                    }
                }
                return accumulator;
            }, {}))
        });
    }
    activateAdjacentLinks(links, target, accumulator) {
        const activeLinks = [];
        links.forEach((childLink, index) => {
            if (target === childLink.source) {
                if (!accumulator[`link-${index}`]) {
                    accumulator[`link-${index}`] = true;
                    activeLinks.push(childLink, ...this.activateAdjacentLinks(links, childLink.target, accumulator));
                }
            }
        });
        return activeLinks;
    }
    onNodeMouseOut(node, event) {
        const { onNodeMouseOut } = this.props;
        this.resetActive();
        onNodeMouseOut({
            nativeEvent: event,
            node,
            links: this.getLinksForNode(node)
        });
    }
    onLinkMouseOut(link, event) {
        const { onLinkMouseOut } = this.props;
        this.resetActive();
        onLinkMouseOut({
            nativeEvent: event,
            link
        });
    }
    onNodeClick(node, event) {
        const { disabled } = this.props;
        if (!disabled) {
            const { onNodeClick } = this.props;
            onNodeClick({
                nativeEvent: event,
                node,
                links: this.getLinksForNode(node)
            });
        }
    }
    getLinksForNode(node) {
        const { links } = this.props;
        return links.filter(link => link.source.value === node.value || link.target.value === node.value);
    }
    resetActive() {
        this.setState({
            active: undefined,
            linkTooltipData: undefined,
            nodeTooltipData: undefined,
            tooltipReference: undefined
        });
    }
    prepareData({ dimension, innerRadius, colorScheme, axis, label }) {
        let outerRadius = dimension / 2;
        if (label.show) {
            outerRadius = outerRadius - (10 + label.padding);
        }
        return {
            angle: scalePoint()
                .domain(range(axis.length + 1))
                .range([0, 2 * Math.PI]),
            radius: scaleLinear().range([innerRadius, outerRadius]),
            axisColor: scaleOrdinal(colorScheme.axis).domain(range(20)),
            domainColor: scaleOrdinal(colorScheme.domain).domain(range(20)),
            outerRadius
        };
    }
    onSize({ height, width }) {
        this.setState(prev => ({
            height: height || prev.height,
            width: width || prev.width
        }));
    }
    getDimensions() {
        const height = this.props.height || this.state.height || 0;
        const width = this.props.width || this.state.width || 0;
        return {
            height,
            width
        };
    }
    renderAxis({ angle, radius, axisColor, outerRadius }) {
        const { axis, label } = this.props;
        return (React.createElement(Fragment, null, axis.map((a, i) => (React.createElement("g", { key: `axis-${a.attribute}` },
            React.createElement(HiveAxis, { angle: angle, index: i, color: axisColor, radius: radius }),
            label.show && (React.createElement(HiveLabel, { index: i, text: a.label, label: label, outerRadius: outerRadius, angle: angle })))))));
    }
    isActive(nodeOrLink, index, type) {
        const { activeIds } = this.props;
        const { active } = this.state;
        // If no there is nothing active, then everything is active.
        if (!active && !activeIds.length) {
            return true;
        }
        // If this node is active because it is being hovered
        if (active && active[`${type}-${index}`]) {
            return true;
        }
        // If the ID matches one of the active IDs passed in the props
        if (!!activeIds.length &&
            !!nodeOrLink.id &&
            activeIds.includes(nodeOrLink.id)) {
            return true;
        }
        return false;
    }
    renderLinks({ angle, radius, domainColor }) {
        const { links } = this.props;
        return (React.createElement(Fragment, null, links.map((link, i) => {
            return (React.createElement(HiveLink, { key: `${link.value}-${i}`, color: link.color || domainColor, active: this.isActive(link, i, 'link'), angle: angle, radius: radius, link: link, onMouseOver: bind(this.onLinkMouseOver, this, link), onMouseOut: bind(this.onLinkMouseOut, this, link) }));
        })));
    }
    renderNodes({ angle, radius, domainColor }) {
        const { nodes, disabled } = this.props;
        return (React.createElement(Fragment, null, nodes.map((node, i) => (React.createElement(HiveNode, { node: node, key: `${node.value}-${i}`, active: this.isActive(node, i, 'node'), color: domainColor, radius: radius, angle: angle, disabled: disabled, onMouseOver: bind(this.onNodeMouseOver, this, node), onMouseOut: bind(this.onNodeMouseOut, this, node), onClick: bind(this.onNodeClick, this, node) })))));
    }
    renderTooltip() {
        const { tooltip, disabled, axis, nodes } = this.props;
        const { active, tooltipReference, linkTooltipData: link, nodeTooltipData: node } = this.state;
        const { formatter, placement, show } = tooltip;
        return (React.createElement(Fragment, null, !disabled && show && (React.createElement(Tooltip, { visible: !!active, reference: tooltipReference, placement: placement, content: () => formatter(axis, nodes, link, node) ||
                (node ? (React.createElement(HiveTooltip, { node: node, nodes: nodes, axis: axis })) : null) }))));
    }
    render() {
        const { innerRadius, axis, colorScheme, label, className } = this.props;
        const { height, width } = this.getDimensions();
        const data = this.prepareData({
            dimension: Math.min(height, width),
            innerRadius,
            colorScheme,
            axis,
            label
        });
        return (React.createElement(ResizeContainer, { onSize: bind(this.onSize, this), height: this.props.height, width: this.props.width }, height && width && (React.createElement(Fragment, null,
            React.createElement("svg", { width: width, height: height, className: classNames(className) },
                React.createElement("g", { transform: `translate(${width / 2}, ${height / 2 +
                        innerRadius})` },
                    this.renderAxis(data),
                    this.renderLinks(data),
                    this.renderNodes(data))),
            this.renderTooltip()))));
    }
}
HivePlot.defaultProps = {
    innerRadius: 20,
    disabled: false,
    axis: [],
    nodes: [],
    links: [],
    label: {
        show: true,
        padding: 10
    },
    activeIds: [],
    onNodeClick: () => undefined,
    onNodeMouseOver: () => undefined,
    onNodeMouseOut: () => undefined,
    onLinkMouseOver: () => undefined,
    onLinkMouseOut: () => undefined,
    tooltip: {
        show: true,
        placement: 'top',
        formatter: attr => attr.value
    },
    colorScheme: {
        axis: ['#b1b2b6'],
        domain: ['#b1b2b6']
    }
};

class LineSeries extends Component {
    render() {
        return React.createElement(AreaSeries, Object.assign({}, this.props));
    }
}
LineSeries.defaultProps = Object.assign(Object.assign({}, AreaSeries.defaultProps), { area: null, line: React.createElement(Line, { strokeWidth: 3 }) });
class LineChart extends Component {
    render() {
        return React.createElement(AreaChart, Object.assign({}, this.props));
    }
}
LineChart.defaultProps = Object.assign(Object.assign({}, AreaChart.defaultProps), { series: React.createElement(LineSeries, null) });

var css$I = ".Map-module_country__17bat {\n  fill: rgba(255, 255, 255, 0.3); }\n";
var css$J = {"country":"Map-module_country__17bat"};
styleInject(css$I);

class Map$1 extends Component {
    getProjection({ chartWidth, chartHeight }) {
        return geoMercator()
            .fitSize([chartWidth, chartHeight], this.props.data)
            .center([0, 35]);
    }
    renderMarker(marker, index, projection) {
        const position = projection(marker.props.coordinates);
        if (!position) {
            console.warn(`Position for ${marker.props.coordinates.toString()} not found.`);
            return null;
        }
        return (React.createElement(CloneElement, { element: marker, cx: position[0], cy: position[1], index: index }));
    }
    renderCountry(point, index, path) {
        // Exclude ATA
        if (point.id === '010') {
            return null;
        }
        return (React.createElement("path", { key: `path-${index}`, d: path(point), className: css$J.country }));
    }
    renderChart(containerProps) {
        const { markers, data } = this.props;
        if (!data) {
            return null;
        }
        const projection = this.getProjection(containerProps);
        const path = geoPath().projection(projection);
        return (React.createElement(motion.g, { initial: {
                opacity: 0
            }, animate: {
                opacity: 1
            } },
            data.features.map((point, index) => this.renderCountry(point, index, path)),
            markers &&
                markers.map((marker, index) => (React.createElement(Fragment, { key: `marker-${index}` }, this.renderMarker(marker, index, projection))))));
    }
    render() {
        const { id, width, height, margins, className } = this.props;
        return (React.createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: false, yAxisVisible: false, className: classNames(className) }, props => this.renderChart(props)));
    }
}

var css$K = ".MapMarker-module_marker__1OAhA {\n  fill: var(--color-primary); }\n";
var css$L = {"marker":"MapMarker-module_marker__1OAhA"};
styleInject(css$K);

// Set padding modifier for the tooltips
const modifiers = {
    offset: {
        offset: '0, 3px'
    }
};
class MapMarker extends Component {
    constructor() {
        super(...arguments);
        this.ref = createRef();
        this.state = {};
    }
    onMouseEnter() {
        this.setState({ active: true });
    }
    onMouseLeave() {
        this.setState({ active: false });
    }
    render() {
        const { cx, cy, tooltip, size, index, onClick } = this.props;
        const { active } = this.state;
        return (React.createElement(Fragment, null,
            React.createElement(motion.circle, { initial: {
                    opacity: 0,
                    scale: 0.02
                }, animate: {
                    opacity: 1,
                    scale: 1
                }, transition: {
                    delay: index * 0.3
                }, ref: this.ref, className: css$L.marker, cx: cx, cy: cy, r: size, onMouseEnter: bind(this.onMouseEnter, this), onMouseLeave: bind(this.onMouseLeave, this), onClick: onClick }),
            tooltip && (React.createElement(Tooltip, { visible: !!active, reference: this.ref, modifiers: modifiers, content: tooltip }))));
    }
}
MapMarker.defaultProps = {
    size: 3,
    onClick: () => undefined
};

const MotionArc = (_a) => {
    var { custom, transition, arc } = _a, rest = __rest(_a, ["custom", "transition", "arc"]);
    const d = useMotionValue(custom.exit);
    const prevPath = useMotionValue(custom.exit);
    const spring = useSpring(prevPath, Object.assign(Object.assign({}, DEFAULT_TRANSITION), { from: 0, to: 1 }));
    useEffect(() => {
        const from = custom.previousEnter || prevPath.get();
        const interpolator = interpolate$1(from, custom.enter);
        const unsub = spring.onChange(v => d.set(arc(interpolator(v))));
        prevPath.set(custom.enter);
        return unsub;
    });
    const { d: enterD } = custom.enter;
    return (React.createElement(motion.path, Object.assign({}, rest, { transition: transition, d: transition.type !== false ? d : enterD })));
};

class PieArc extends Component {
    constructor() {
        super(...arguments);
        this.arc = createRef();
        this.state = {
            active: false
        };
    }
    getExitProps() {
        const { data, animated } = this.props;
        const startAngle = data.startAngle;
        const endAngle = animated ? startAngle : data.endAngle;
        return Object.assign(Object.assign({}, data), { startAngle,
            endAngle });
    }
    onMouseEnter(event) {
        const { onMouseEnter, data, disabled } = this.props;
        if (!disabled) {
            this.setState({ active: true });
            onMouseEnter({
                value: data.data,
                nativeEvent: event
            });
        }
    }
    onMouseLeave(event) {
        const { onMouseLeave, data, disabled } = this.props;
        if (!disabled) {
            this.setState({ active: false });
            onMouseLeave({
                value: data.data,
                nativeEvent: event
            });
        }
    }
    onMouseClick(event) {
        const { onClick, data, disabled } = this.props;
        if (!disabled) {
            onClick({
                value: data.data,
                nativeEvent: event
            });
        }
    }
    getTransition() {
        const { animated } = this.props;
        if (animated) {
            return Object.assign({}, DEFAULT_TRANSITION);
        }
        else {
            return {
                type: false,
                delay: 0
            };
        }
    }
    render() {
        const { color, data, tooltip, cursor, innerArc } = this.props;
        const { active } = this.state;
        const exit = this.getExitProps();
        const fill = active ? chroma(color).brighten(0.5) : color;
        const transition = this.getTransition();
        // Cache the previous for transition use later
        const previousEnter = this.previousEnter
            ? Object.assign({}, this.previousEnter) : undefined;
        this.previousEnter = Object.assign({}, data);
        return (React.createElement("g", { ref: this.arc },
            React.createElement(MotionArc, { style: { cursor }, fill: fill, arc: innerArc, custom: {
                    enter: data,
                    exit,
                    previousEnter
                }, transition: transition, onMouseEnter: bind(this.onMouseEnter, this), onMouseLeave: bind(this.onMouseLeave, this), onClick: bind(this.onMouseClick, this) }),
            tooltip && !tooltip.props.disabled && (React.createElement(CloneElement, { element: tooltip, visible: !!active, reference: this.arc, value: { y: data.data.data, x: data.data.key } }))));
    }
}
PieArc.defaultProps = {
    cursor: 'initial',
    disabled: false,
    onClick: () => undefined,
    onMouseEnter: () => undefined,
    onMouseLeave: () => undefined,
    tooltip: React.createElement(ChartTooltip, null)
};

const getTextAnchor = ({ startAngle, endAngle }) => startAngle + (endAngle - startAngle) / 2 < Math.PI ? 'start' : 'end';
class PieArcLabel extends PureComponent {
    render() {
        const { centroid, data, lineStroke, padding, fontSize, fontFill, format, fontFamily, position } = this.props;
        const text = format ? format(data.data) : formatValue(data.data.key);
        const textAnchor = getTextAnchor(data);
        const [posX, posY] = position;
        const innerLinePos = centroid(data);
        let scale = posY / innerLinePos[1];
        if (posY === 0 || innerLinePos[1] === 0) {
            scale = 1;
        }
        const outerPos = [scale * innerLinePos[0], scale * innerLinePos[1]];
        return (React.createElement(motion.g, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: {
                duration: 0.1
            } },
            React.createElement("title", null, text),
            React.createElement("text", { dy: padding, fill: fontFill, fontSize: fontSize, fontFamily: fontFamily, textAnchor: textAnchor, style: {
                    shapeRendering: 'crispEdges',
                    transform: `translate3d(${posX}px,${posY}px, 0)`
                } }, text),
            React.createElement("polyline", { fill: "none", stroke: lineStroke, points: `${innerLinePos},${outerPos},${posX} ${posY}` })));
    }
}
PieArcLabel.defaultProps = {
    format: undefined,
    lineStroke: 'rgba(127,127,127,0.5)',
    fontFill: '#8F979F',
    fontSize: 11,
    fontFamily: 'sans-serif',
    padding: '.35em'
};

const factor = 1.2;
const midAngle = d => d.startAngle + (d.endAngle - d.startAngle) / 2;
const labelVisible = arc => arc.endAngle - arc.startAngle > Math.PI / 30;
class PieArcSeries extends Component {
    calculateRadius() {
        const { doughnut, arcWidth, label, width, height } = this.props;
        const outerRadius = Math.min(width, height) / (label ? 3 : 2);
        const innerRadius = doughnut ? outerRadius * (1 - arcWidth) : 0;
        return {
            outerRadius,
            innerRadius
        };
    }
    shouldDisplayLabel(arcData) {
        const { displayAllLabels } = this.props;
        return displayAllLabels || labelVisible(arcData);
    }
    calculateLabelPositions(outerArc, outerRadius) {
        const { label, data } = this.props;
        const positions = data.map(d => {
            const pos = outerArc.centroid(d);
            pos[0] = factor * outerRadius * (midAngle(d) < Math.PI ? 1 : -1);
            return pos;
        });
        if (label) {
            const minDistance = 15;
            for (let i = 0; i < data.length - 1; i++) {
                const a = data[i];
                if (!this.shouldDisplayLabel(a)) {
                    continue;
                }
                const [aPosX, aPosY] = positions[i];
                for (let j = i + 1; j < data.length; j++) {
                    const b = data[j];
                    if (!this.shouldDisplayLabel(b)) {
                        continue;
                    }
                    // if they're on the same side
                    const [bPosX, bPosY] = positions[j];
                    if (bPosX * aPosX > 0) {
                        // if they're overlapping
                        const o = minDistance - Math.abs(bPosY - aPosY);
                        if (o > 0) {
                            // push the second up or down
                            positions[j][1] += Math.sign(bPosX) * o;
                        }
                    }
                }
            }
        }
        return positions;
    }
    innerArc(innerRadius, outerRadius) {
        return point => {
            const newOuter = this.calculateOuterRadius(outerRadius, point);
            return arc()
                .innerRadius(innerRadius)
                .outerRadius(newOuter)(point);
        };
    }
    calculateOuterRadius(outerRadius, point) {
        const { explode, data } = this.props;
        if (!explode) {
            return outerRadius;
        }
        const maxVal = max(data, d => d.value);
        let newOuter = outerRadius;
        if (explode && data !== undefined) {
            newOuter = (outerRadius * point.value) / maxVal;
        }
        return newOuter;
    }
    centroid(innerRadius, outerRadius) {
        return data => {
            const newOuter = this.calculateOuterRadius(outerRadius, data);
            return arc()
                .innerRadius(innerRadius)
                .outerRadius(newOuter)
                .centroid(data);
        };
    }
    outerArc(outerRadius) {
        return arc()
            .innerRadius(outerRadius * factor)
            .outerRadius(outerRadius * factor);
    }
    render() {
        const { animated, label, arc, data } = this.props;
        const { outerRadius, innerRadius } = this.calculateRadius();
        const innerArc = this.innerArc(innerRadius, outerRadius);
        const outerArc = this.outerArc(outerRadius);
        const positions = this.calculateLabelPositions(outerArc, outerRadius);
        const centroid = this.centroid(innerRadius, outerRadius);
        return (React.createElement(Fragment, null, data.map((arcData, index) => (React.createElement(Fragment, { key: arcData.data.key.toString() },
            label && this.shouldDisplayLabel(arcData) && (React.createElement(CloneElement, { element: label, data: arcData, centroid: centroid, position: positions[index] })),
            React.createElement(CloneElement, { element: arc, data: arcData, animated: animated, innerArc: innerArc, color: getColor({
                    data: this.props.data,
                    colorScheme: this.props.colorScheme,
                    point: arcData.data,
                    index
                }) }))))));
    }
}
PieArcSeries.defaultProps = {
    animated: true,
    colorScheme: 'cybertron',
    innerRadius: 0,
    explode: false,
    displayAllLabels: false,
    arcWidth: 0.25,
    label: React.createElement(PieArcLabel, null),
    arc: React.createElement(PieArc, null)
};

class PieChart extends Component {
    constructor() {
        super(...arguments);
        this.getData = memoize((data, explode) => {
            const pieLayout = pie().value((d) => d.data);
            // Explode sort doesn't work right...
            if (!explode) {
                pieLayout.sort(null);
            }
            return pieLayout(data);
        });
    }
    renderChart(containerProps) {
        const { chartWidth, chartHeight } = containerProps;
        const { series, displayAllLabels } = this.props;
        const data = this.getData(this.props.data, this.props.series.props.explode);
        return (React.createElement(CloneElement, { element: series, data: data, height: chartHeight, width: chartWidth, displayAllLabels: displayAllLabels }));
    }
    render() {
        const { id, width, height, margins, className } = this.props;
        return (React.createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: false, yAxisVisible: false, center: true, className: classNames(className) }, props => this.renderChart(props)));
    }
}
PieChart.defaultProps = {
    disabled: false,
    displayAllLabels: false,
    data: [],
    margins: 10,
    series: (React.createElement(PieArcSeries, { animated: true, doughnut: false, innerRadius: 0, arcWidth: 0.25, displayAllLabels: false }))
};

const JUSTIFICATION = {
    justify: sankeyJustify,
    center: sankeyCenter,
    left: sankeyLeft,
    right: sankeyRight
};
class Sankey extends Component {
    constructor() {
        super(...arguments);
        this.state = { activeNodes: [], activeLinks: [] };
    }
    getNodeColor(node, index) {
        const { colorScheme, nodes } = this.props;
        if (colorScheme) {
            return getColor({
                data: nodes,
                colorScheme,
                point: nodes[index],
                index
            });
        }
        else {
            return node.props.color;
        }
    }
    onNodeActive(node) {
        const activeNodes = [node];
        const activeLinks = [];
        if (node.sourceLinks) {
            activeLinks.push(...node.sourceLinks);
            node.sourceLinks.forEach(sourceLink => {
                const sourceLinkTarget = sourceLink.target;
                if (sourceLinkTarget.index !== node.index) {
                    activeNodes.push(sourceLinkTarget);
                }
            });
        }
        if (node.targetLinks) {
            activeLinks.push(...node.targetLinks);
            node.targetLinks.forEach(targetLink => {
                const targetLinkSource = targetLink.source;
                if (targetLinkSource.index !== node.index) {
                    activeNodes.push(targetLinkSource);
                }
            });
        }
        this.setState({ activeNodes, activeLinks });
    }
    onLinkActive(link) {
        const activeNodes = [link.source, link.target];
        const activeLinks = [link];
        this.setState({ activeNodes, activeLinks });
    }
    onInactive() {
        this.setState({ activeNodes: [], activeLinks: [] });
    }
    renderNode(computedNode, index, chartWidth, node) {
        const { animated } = this.props;
        const { activeNodes } = this.state;
        const active = activeNodes.some(node => node.index === computedNode.index);
        const disabled = activeNodes.length > 0 && !active;
        return (React.createElement(CloneElement, Object.assign({ element: node, key: `node-${index}`, active: active, animated: animated, disabled: disabled, chartWidth: chartWidth, onMouseEnter: bind(this.onNodeActive, this, computedNode), onMouseLeave: bind(this.onInactive, this, computedNode) }, computedNode)));
    }
    renderNodes(nodes, chartWidth) {
        const nodeMap = new Map();
        this.props.nodes.forEach(node => node && nodeMap.set(node.props.title, node));
        nodes.sort((a, b) => {
            const aX0 = a && a.x0 ? a.x0 : 0;
            const aY0 = a && a.y0 ? a.y0 : 0;
            const bX0 = b && b.x0 ? b.x0 : 0;
            const bY0 = b && b.y0 ? b.y0 : 0;
            return aX0 - bX0 || aY0 - bY0;
        });
        return (React.createElement(Fragment, null, nodes.map((node, index) => this.renderNode(node, index, chartWidth, nodeMap.get(node.title)))));
    }
    renderLink(computedLink, index, chartId) {
        const { animated, links } = this.props;
        const { activeLinks } = this.state;
        const active = activeLinks.some(link => link.index === computedLink.index);
        const disabled = activeLinks.length > 0 && !active;
        return (React.createElement(CloneElement, Object.assign({ element: links[index], active: active, animated: animated, key: `link-${index}`, chartId: chartId, disabled: disabled }, computedLink, { onMouseEnter: bind(this.onLinkActive, this, computedLink), onMouseLeave: bind(this.onInactive, this, computedLink) })));
    }
    renderChart(containerProps) {
        const { id, chartWidth, chartHeight } = containerProps;
        const { justification, nodeWidth, nodePadding } = this.props;
        const nodesCopy = this.props.nodes.map((node, index) => ({
            id: node.props.id,
            title: node.props.title,
            color: this.getNodeColor(node, index)
        }));
        const linksCopy = this.props.links.map(link => ({
            source: link.props.source,
            target: link.props.target,
            value: link.props.value
        }));
        const sankeyChart = sankey()
            .extent([[1, 1], [chartWidth, chartHeight]])
            .nodeWidth(nodeWidth)
            .nodePadding(nodePadding)
            .nodeAlign(JUSTIFICATION[justification])
            .nodeId((node) => node.id || node.index);
        const { nodes, links } = sankeyChart({
            nodes: nodesCopy,
            links: linksCopy
        });
        return (containerProps.chartSized && (React.createElement(Fragment, { key: "group" },
            links.map((link, index) => this.renderLink(link, index, `sankey-${id}`)),
            this.renderNodes(nodes, chartWidth))));
    }
    render() {
        const { id, width, height, margins, className } = this.props;
        return (React.createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, className: className }, props => this.renderChart(props)));
    }
}
Sankey.defaultProps = {
    animated: true,
    justification: 'justify',
    nodeWidth: 15,
    nodePadding: 10
};

var css$M = ".SankeyLabel-module_label__3--L3 {\n  font-size: 12px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  pointer-events: none; }\n";
var css$N = {"label":"SankeyLabel-module_label__3--L3"};
styleInject(css$M);

class SankeyLabel extends Component {
    render() {
        const { active, chartWidth, className, fill, node, opacity, padding, visible } = this.props;
        const nodePositions = {
            x0: node && node.x0 ? node.x0 : 0,
            y0: node && node.y0 ? node.y0 : 0,
            x1: node && node.x1 ? node.x1 : 0,
            y1: node && node.y1 ? node.y1 : 0
        };
        const width = chartWidth || 0;
        const showRightSide = nodePositions.x0 < width / 2;
        const textAnchor = showRightSide ? 'start' : 'end';
        return (visible &&
            node && (React.createElement("text", { className: classNames(css$N.label, className), x: showRightSide ? nodePositions.x1 + 6 : nodePositions.x0 - 6, y: (nodePositions.y1 + nodePositions.y0) / 2, dy: "0.35em", textAnchor: textAnchor, fill: fill, opacity: opacity(active), style: { padding } }, node.title)));
    }
}
SankeyLabel.defaultProps = {
    active: false,
    fill: '#fff',
    location: 'outside',
    opacity: active => (active ? 1 : 0.5),
    visible: true
};

const DEFAULT_COLOR = 'rgba(255, 255, 255, 0.2)';

var css$O = ".SankeyLink-module_link__1C-v0 {\n  fill: none;\n  -webkit-transition: stroke-opacity 100ms ease-in-out, stroke 100ms ease-in-out;\n  transition: stroke-opacity 100ms ease-in-out, stroke 100ms ease-in-out;\n  mix-blend-mode: screen; }\n\n.SankeyLink-module_tooltip__2dubX {\n  text-align: center; }\n  .SankeyLink-module_tooltip__2dubX .SankeyLink-module_tooltipLabel__2SWlT {\n    font-size: 16px;\n    margin-bottom: 3px;\n    color: white;\n    text-align: center; }\n  .SankeyLink-module_tooltip__2dubX .SankeyLink-module_tooltipValue__2a0NJ {\n    font-size: 13px;\n    color: rgba(255, 255, 255, 0.7);\n    text-align: center; }\n";
var css$P = {"link":"SankeyLink-module_link__1C-v0","tooltip":"SankeyLink-module_tooltip__2dubX","tooltipLabel":"SankeyLink-module_tooltipLabel__2SWlT","tooltipValue":"SankeyLink-module_tooltipValue__2a0NJ"};
styleInject(css$O);

class SankeyLink extends Component {
    constructor() {
        super(...arguments);
        this.link = createRef();
        this.state = {};
    }
    getEnter() {
        const path = sankeyLinkHorizontal();
        const d = path(this.getLink());
        const strokeWidth = Math.max(1, this.props.width);
        return { d, strokeWidth };
    }
    getExit() {
        const path = sankeyLinkHorizontal();
        const d = path(Object.assign(Object.assign({}, this.getLink()), { width: 0 }));
        return { d, strokeWidth: 0 };
    }
    getLink() {
        const { index, value, y0, y1, source, target, width } = this.props;
        return { index, y0, y1, value, width, source, target };
    }
    getStroke() {
        const { color, index, gradient, chartId } = this.props;
        return gradient ? `url(#${chartId}-gradient-${index})` : color;
    }
    onMouseEnter(event) {
        this.setState({ hovered: true });
        this.props.onMouseEnter(event);
    }
    onMouseLeave(event) {
        this.setState({ hovered: false });
        this.props.onMouseLeave(event);
    }
    renderLink() {
        const { active, className, disabled, index, opacity, style, onClick } = this.props;
        const enterProps = this.getEnter();
        const exitProps = this.getExit();
        return (React.createElement("g", { ref: this.link },
            React.createElement(motion.path, { key: `sankey-link-${enterProps.d}-${index}`, className: classNames(css$P.link, className), style: style, initial: exitProps, animate: enterProps, exit: exitProps, transition: {
                    duration: 0.5
                }, stroke: this.getStroke(), strokeOpacity: opacity(active, disabled), onClick: onClick, onMouseEnter: bind(this.onMouseEnter, this), onMouseLeave: bind(this.onMouseLeave, this) })));
    }
    renderTooltipContent() {
        const { source, target, value } = this.props;
        return (React.createElement("div", { className: css$P.tooltip },
            React.createElement("div", { className: css$P.tooltipLabel }, `${source.title}  ${target.title}`),
            React.createElement("div", { className: css$P.tooltipValue }, formatValue(value))));
    }
    render() {
        const { gradient, index, source, target, tooltip, chartId } = this.props;
        const linkSource = source;
        const linkTarget = target;
        return (React.createElement(Fragment, null,
            gradient && (React.createElement("linearGradient", { id: `${chartId}-gradient-${index}`, gradientUnits: "userSpaceOnUse", x1: linkSource.x1, x2: linkTarget.x0 },
                React.createElement("stop", { offset: "0%", stopColor: linkSource.color }),
                React.createElement("stop", { offset: "100%", stopColor: linkTarget.color }))),
            this.renderLink(),
            !tooltip.props.disabled && (React.createElement(CloneElement, { content: this.renderTooltipContent.bind(this), element: tooltip, visible: this.state.hovered, reference: this.link }))));
    }
}
SankeyLink.defaultProps = {
    active: false,
    animated: true,
    color: DEFAULT_COLOR,
    disabled: false,
    gradient: true,
    opacity: (active, disabled) => (active ? 0.5 : disabled ? 0.1 : 0.35),
    tooltip: (React.createElement(Tooltip, { followCursor: true, modifiers: {
            offset: {
                offset: '0, 5px'
            }
        } })),
    width: 0,
    onClick: () => undefined,
    onMouseEnter: () => undefined,
    onMouseLeave: () => undefined
};

var css$Q = ".SankeyNode-module_node__2SPsh {\n  -webkit-transition: opacity 100ms ease-in-out, fill-opacity 100ms ease-in-out;\n  transition: opacity 100ms ease-in-out, fill-opacity 100ms ease-in-out; }\n\n.SankeyNode-module_tooltip__1VhLz {\n  text-align: center;\n  padding: 0 8px; }\n  .SankeyNode-module_tooltip__1VhLz .SankeyNode-module_tooltipLabel__1mNmp {\n    font-size: 16px;\n    margin-bottom: 3px;\n    color: white;\n    text-align: center; }\n  .SankeyNode-module_tooltip__1VhLz .SankeyNode-module_tooltipValue__1Hirb {\n    font-size: 13px;\n    color: rgba(255, 255, 255, 0.7);\n    text-align: center; }\n";
var css$R = {"node":"SankeyNode-module_node__2SPsh","tooltip":"SankeyNode-module_tooltip__1VhLz","tooltipLabel":"SankeyNode-module_tooltipLabel__1mNmp","tooltipValue":"SankeyNode-module_tooltipValue__1Hirb"};
styleInject(css$Q);

class SankeyNode extends Component {
    constructor() {
        super(...arguments);
        this.state = {};
        this.rect = createRef();
    }
    getNode() {
        const { id, title, color, sourceLinks, targetLinks, value, index, x0, x1, y0, y1 } = this.props;
        return {
            id,
            title,
            color,
            sourceLinks,
            targetLinks,
            value,
            index,
            x0,
            x1,
            y0,
            y1
        };
    }
    onMouseEnter(event) {
        this.setState({ hovered: true });
        this.props.onMouseEnter(event);
    }
    onMouseLeave(event) {
        this.setState({ hovered: false });
        this.props.onMouseLeave(event);
    }
    renderNode() {
        const { active, className, color, disabled, index, opacity, style, width, x0, x1, y0, y1, onClick } = this.props;
        const nodeWidth = width || (x1 && x0 && x1 - x0 > 0 ? x1 - x0 : 0);
        const nodeHeight = y1 && y0 && y1 - y0 > 0 ? y1 - y0 : 0;
        return (React.createElement("g", { ref: this.rect },
            React.createElement(motion.rect, { key: `sankey-node-${x0}-${x1}-${y0}-${y1}-${index}`, className: classNames(css$R.node, className), fillOpacity: opacity(active, disabled), style: style, x: x0, y: y0, width: nodeWidth, height: nodeHeight, fill: color, initial: {
                    opacity: 0
                }, animate: {
                    opacity: 1
                }, exit: {
                    opacity: 0
                }, transition: {
                    duration: 0.1
                }, onClick: onClick, onMouseEnter: bind(this.onMouseEnter, this), onMouseLeave: bind(this.onMouseLeave, this) })));
    }
    renderTooltipContent() {
        const { title, value } = this.props;
        return (React.createElement("div", { className: css$R.tooltip },
            React.createElement("div", { className: css$R.tooltipLabel }, title),
            React.createElement("div", { className: css$R.tooltipValue }, formatValue(value))));
    }
    render() {
        const { active, chartWidth, label, tooltip, showLabel } = this.props;
        return (React.createElement(Fragment, null,
            this.renderNode(),
            showLabel && (React.createElement(CloneElement, { active: active, element: label, chartWidth: chartWidth, node: this.getNode() })),
            !tooltip.props.disabled && (React.createElement(CloneElement, { content: this.renderTooltipContent.bind(this), element: tooltip, visible: this.state.hovered, reference: this.rect }))));
    }
}
SankeyNode.defaultProps = {
    active: false,
    animated: true,
    color: DEFAULT_COLOR,
    disabled: false,
    label: React.createElement(SankeyLabel, null),
    opacity: (active, disabled) => (active ? 1 : disabled ? 0.2 : 0.9),
    showLabel: true,
    tooltip: (React.createElement(Tooltip, { followCursor: true, modifiers: {
            offset: {
                offset: '0, 5px'
            }
        } })),
    onClick: () => undefined,
    onMouseEnter: () => undefined,
    onMouseLeave: () => undefined
};

class SparklineChart extends Component {
    render() {
        return React.createElement(LineChart, Object.assign({}, this.props));
    }
}
SparklineChart.defaultProps = {
    gridlines: null,
    series: (React.createElement(AreaSeries, { symbols: React.createElement(PointSeries, { show: "hover" }), interpolation: "smooth", markLine: null, area: null, line: React.createElement(Line, { strokeWidth: 2 }) })),
    yAxis: (React.createElement(LinearYAxis, { scaled: true, type: "value", axisLine: null, tickSeries: React.createElement(LinearYAxisTickSeries, { line: null, label: null }) })),
    xAxis: (React.createElement(LinearXAxis, { type: "time", scaled: true, axisLine: null, tickSeries: React.createElement(LinearXAxisTickSeries, { line: null, label: null }) }))
};

class AreaSparklineChart extends Component {
    render() {
        return React.createElement(AreaChart, Object.assign({}, this.props));
    }
}
AreaSparklineChart.defaultProps = {
    gridlines: null,
    series: (React.createElement(AreaSeries, { symbols: React.createElement(PointSeries, { show: "hover" }), interpolation: "smooth", markLine: null, area: React.createElement(Area, { mask: React.createElement(Stripes, null), gradient: React.createElement(Gradient, { stops: [
                    React.createElement(GradientStop, { offset: "10%", stopOpacity: 0, key: "start" }),
                    React.createElement(GradientStop, { offset: "80%", stopOpacity: 1, key: "stop" })
                ] }) }), line: React.createElement(Line, { strokeWidth: 3 }) })),
    yAxis: (React.createElement(LinearYAxis, { type: "value", scaled: true, axisLine: null, tickSeries: React.createElement(LinearYAxisTickSeries, { line: null, label: null }) })),
    xAxis: (React.createElement(LinearXAxis, { type: "time", scaled: true, axisLine: null, tickSeries: React.createElement(LinearXAxisTickSeries, { line: null, label: null }) }))
};

class BarSparklineChart extends Component {
    render() {
        return React.createElement(BarChart, Object.assign({}, this.props));
    }
}
BarSparklineChart.defaultProps = {
    gridlines: null,
    series: React.createElement(BarSeries, { colorScheme: schemes.cybertron[0] }),
    yAxis: (React.createElement(LinearYAxis, { type: "value", axisLine: null, tickSeries: React.createElement(LinearYAxisTickSeries, { line: null, label: null }) })),
    xAxis: (React.createElement(LinearXAxis, { type: "category", axisLine: null, tickSeries: React.createElement(LinearXAxisTickSeries, { line: null, label: null }) }))
};

const SonarChart = props => (React.createElement(StackedBarChart, Object.assign({}, props, { margins: 0, gridlines: null, series: React.createElement(StackedBarSeries, { type: "stackedDiverging", colorScheme: "rgb(17, 207, 247)", tooltip: React.createElement(TooltipArea, { tooltip: React.createElement(ChartTooltip, { followCursor: true, modifiers: {
                    offset: '5px, 5px'
                }, content: (data, color) => (React.createElement(TooltipTemplate, { color: color, value: {
                        x: formatValue(data.x),
                        y: `${formatValue(Math.abs(data.data[0].y))}`
                    } })) }) }), bar: [
            React.createElement(Bar, { rounded: false, width: 1, rangeLines: null, minHeight: 1, gradient: React.createElement(Gradient, { stops: [
                        React.createElement(GradientStop, { offset: "5%", stopOpacity: 0.7, key: "start" }),
                        React.createElement(GradientStop, { offset: "90%", stopOpacity: 1, key: "stop" })
                    ] }) }),
            React.createElement(Bar, { rounded: false, width: 1, rangeLines: null, minHeight: 1, gradient: React.createElement(Gradient, { stops: [
                        React.createElement(GradientStop, { offset: "5%", stopOpacity: 1, key: "stop" }),
                        React.createElement(GradientStop, { offset: "90%", stopOpacity: 0.7, key: "start" })
                    ] }) })
        ] }), yAxis: React.createElement(LinearYAxis, { type: "value", axisLine: null, tickSeries: React.createElement(LinearYAxisTickSeries, { line: null, label: null }) }), xAxis: React.createElement(LinearXAxis, { type: "category", axisLine: null, tickSeries: React.createElement(LinearXAxisTickSeries, { line: null, label: null }) }) })));

class RadialArea extends Component {
    getFill(color) {
        const { id, gradient } = this.props;
        if (!gradient) {
            return color;
        }
        return `url(#${id}-gradient)`;
    }
    getPath(data) {
        const { xScale, yScale, innerRadius, interpolation } = this.props;
        const curve = interpolation === 'smooth' ? curveCardinalClosed : curveLinearClosed;
        const radialFn = radialArea()
            .angle((d) => xScale(d.x))
            .innerRadius(_ => innerRadius)
            .outerRadius((d) => yScale(d.y))
            .curve(curve);
        return radialFn(data);
    }
    getTransition() {
        const { animated } = this.props;
        if (animated) {
            return Object.assign({}, DEFAULT_TRANSITION);
        }
        else {
            return {
                type: false,
                delay: 0
            };
        }
    }
    renderArea(fill) {
        const { data, className, yScale } = this.props;
        const transition = this.getTransition();
        const enter = {
            d: this.getPath(data),
            opacity: 1
        };
        const [yStart] = yScale.domain();
        const exit = {
            d: this.getPath(data.map(d => (Object.assign(Object.assign({}, d), { y: yStart })))),
            opacity: 0
        };
        return (React.createElement(MotionPath, { custom: {
                enter,
                exit
            }, transition: transition, pointerEvents: "none", className: className, fill: this.getFill(fill) }));
    }
    render() {
        const { data, color, id, gradient, outerRadius } = this.props;
        const fill = color(data, 0);
        return (React.createElement(Fragment, null,
            this.renderArea(fill),
            gradient && (React.createElement(CloneElement, { element: gradient, id: `${id}-gradient`, radius: outerRadius, color: fill }))));
    }
}
RadialArea.defaultProps = {
    gradient: React.createElement(RadialGradient, null)
};

class RadialLine extends Component {
    getPath(data) {
        const { xScale, yScale, interpolation } = this.props;
        const curve = interpolation === 'smooth' ? curveCardinalClosed : curveLinearClosed;
        const radialFn = radialLine()
            .angle((d) => xScale(d.x))
            .radius((d) => yScale(d.y))
            .curve(curve);
        return radialFn(data);
    }
    getTransition() {
        const { animated } = this.props;
        if (animated) {
            return Object.assign({}, DEFAULT_TRANSITION);
        }
        else {
            return {
                type: false,
                delay: 0
            };
        }
    }
    render() {
        const { data, color, strokeWidth, className, yScale } = this.props;
        const fill = color(data, 0);
        const transition = this.getTransition();
        const enter = {
            d: this.getPath(data),
            opacity: 1
        };
        const [yStart] = yScale.domain();
        const exit = {
            d: this.getPath(data.map(d => (Object.assign(Object.assign({}, d), { y: yStart })))),
            opacity: 0
        };
        return (React.createElement(MotionPath, { custom: {
                enter,
                exit
            }, transition: transition, className: className, pointerEvents: "none", stroke: fill, fill: "none", strokeWidth: strokeWidth }));
    }
}
RadialLine.defaultProps = {
    strokeWidth: 2
};

var css$S = ".RadialScatterPoint-module_inactive__3cq4W {\n  opacity: 0.4;\n  -webkit-transition: opacity 200ms ease-in-out;\n  transition: opacity 200ms ease-in-out; }\n";
var css$T = {"inactive":"RadialScatterPoint-module_inactive__3cq4W"};
styleInject(css$S);

class RadialScatterPoint extends Component {
    constructor() {
        super(...arguments);
        this.ref = createRef();
        this.state = {
            hovered: false
        };
    }
    onMouseEnter(event) {
        this.setState({ hovered: true });
        const { onMouseEnter, data } = this.props;
        onMouseEnter({
            value: data,
            nativeEvent: event
        });
    }
    onMouseLeave(event) {
        this.setState({ hovered: false });
        const { onMouseLeave, data } = this.props;
        onMouseLeave({
            value: data,
            nativeEvent: event
        });
    }
    onClick(event) {
        const { onClick, data } = this.props;
        onClick({
            value: data,
            nativeEvent: event
        });
    }
    getTranslate(data) {
        const { xScale, yScale } = this.props;
        const fn = radialLine()
            .radius((d) => yScale(d.y))
            .angle((d) => xScale(d.x));
        // Parse the generated path to get point coordinates
        // Ref: https://bit.ly/2CnZcPl
        const path = fn([data]);
        if (path) {
            const [translateX, translateY] = path
                .slice(1)
                .slice(0, -1)
                .split(',');
            return {
                translateX: parseFloat(translateX),
                translateY: parseFloat(translateY)
            };
        }
    }
    getTransition() {
        const { animated, index } = this.props;
        if (animated) {
            return Object.assign(Object.assign({}, DEFAULT_TRANSITION), { delay: index * 0.005 });
        }
        else {
            return {
                type: false,
                delay: 0
            };
        }
    }
    render() {
        const { size, data, color, index, symbol, active, tooltip, yScale, className } = this.props;
        const { hovered } = this.state;
        const fill = typeof color === 'function' ? color(data, index) : color;
        const transform = this.getTranslate(data);
        const sizeVal = typeof size === 'function' ? size(data) : size;
        const transition = this.getTransition();
        const [yStart] = yScale.domain();
        const exitTransform = this.getTranslate(Object.assign(Object.assign({}, data), { y: yStart }));
        return (React.createElement(Fragment, null,
            React.createElement(motion.g, { initial: Object.assign(Object.assign({}, exitTransform), { opacity: 0 }), animate: Object.assign(Object.assign({}, transform), { opacity: 1 }), exit: Object.assign(Object.assign({}, exitTransform), { opacity: 0 }), transition: transition, ref: this.ref, onMouseEnter: bind(this.onMouseEnter, this), onMouseLeave: bind(this.onMouseLeave, this), onClick: bind(this.onClick, this), className: classNames(className, {
                    [css$T.inactive]: !active
                }) },
                symbol && symbol(data),
                !symbol && React.createElement("circle", { r: sizeVal, fill: fill })),
            tooltip && (React.createElement(CloneElement, { element: tooltip, visible: hovered, reference: this.ref, value: data }))));
    }
}
RadialScatterPoint.defaultProps = {
    size: 3,
    color: schemes.cybertron[0],
    tooltip: React.createElement(ChartTooltip, null),
    active: true,
    onClick: () => undefined,
    onMouseEnter: () => undefined,
    onMouseLeave: () => undefined
};

class RadialScatterSeries extends Component {
    constructor() {
        super(...arguments);
        this.state = {
            activeIds: []
        };
    }
    onMouseEnter({ value }) {
        // Only perform this on unmanaged activations
        if (!this.props.activeIds) {
            this.setState({
                activeIds: [value.id]
            });
        }
    }
    onMouseLeave() {
        // Only perform this on unmanaged activations
        if (!this.props.activeIds) {
            this.setState({
                activeIds: []
            });
        }
    }
    renderPoint(data, index) {
        const { point, xScale, yScale, animated } = this.props;
        let dataId;
        if (data.id) {
            dataId = data.id;
        }
        else {
            console.warn(`No 'id' property provided for scatter point; provide one via 'id'.`);
        }
        const key = dataId || index;
        const activeIds = this.props.activeIds || this.state.activeIds;
        const active = !(activeIds && activeIds.length) || activeIds.includes(dataId);
        const visible = point.props.visible;
        if (visible && !visible(data, index)) {
            return React.createElement(Fragment, { key: key });
        }
        return (React.createElement(CloneElement, { element: point, key: key, data: data, index: index, active: active, xScale: xScale, yScale: yScale, animated: animated, onMouseEnter: bind(this.onMouseEnter, this), onMouseLeave: bind(this.onMouseLeave, this) }));
    }
    render() {
        const { data } = this.props;
        return React.createElement(Fragment, null, data.map((d, i) => this.renderPoint(d, i)));
    }
}
RadialScatterSeries.defaultProps = {
    point: React.createElement(RadialScatterPoint, null),
    animated: true
};

class RadialScatterPlot extends Component {
    constructor() {
        super(...arguments);
        this.getScales = memoize((preData, outerRadius, innerRadius) => {
            const data = buildShallowChartData(preData);
            const yDomain = getYDomain({ data, scaled: false });
            const xDomain = getXDomain({ data });
            const xScale = scaleTime()
                .range([0, 2 * Math.PI])
                .domain(xDomain);
            const yScale = getRadialYScale(innerRadius, outerRadius, yDomain);
            return {
                yScale,
                xScale,
                data
            };
        });
    }
    renderChart(containerProps) {
        const { chartWidth, chartHeight, id } = containerProps;
        const { innerRadius, series, axis } = this.props;
        const outerRadius = Math.min(chartWidth, chartHeight) / 2;
        const { yScale, xScale, data } = this.getScales(this.props.data, outerRadius, innerRadius);
        return (React.createElement(Fragment, null,
            axis && (React.createElement(CloneElement, { element: axis, xScale: xScale, height: chartHeight, width: chartWidth, innerRadius: innerRadius })),
            React.createElement(CloneElement, { element: series, id: id, data: data, xScale: xScale, yScale: yScale })));
    }
    render() {
        const { id, width, height, margins, className } = this.props;
        return (React.createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: false, yAxisVisible: false, center: true, className: className }, this.renderChart.bind(this)));
    }
}
RadialScatterPlot.defaultProps = {
    innerRadius: 80,
    margins: 75,
    axis: React.createElement(RadialAxis, null),
    series: React.createElement(RadialScatterSeries, null)
};

class RadialPointSeries extends Component {
    isVisible(point, index) {
        const { show, activeValues, data } = this.props;
        const isActive = activeValues && point && isEqual(activeValues.x, point.x);
        if (show === 'hover') {
            return isActive;
        }
        else if (show === 'first') {
            if (activeValues) {
                return isActive;
            }
            else {
                return index === 0;
            }
        }
        else if (show === 'last') {
            if (activeValues) {
                return isActive;
            }
            else {
                return index === data.length - 1;
            }
        }
        return show;
    }
    render() {
        const { data, xScale, yScale, animated, point, color } = this.props;
        return (React.createElement(RadialScatterSeries, { animated: animated, data: data, xScale: xScale, yScale: yScale, point: React.createElement(CloneElement, { element: point, color: color, tooltip: null, visible: this.isVisible.bind(this) }) }));
    }
}
RadialPointSeries.defaultProps = {
    show: 'hover',
    point: React.createElement(RadialScatterPoint, null)
};

class RadialAreaSeries extends Component {
    constructor() {
        super(...arguments);
        this.state = {};
    }
    getColor(point, index) {
        const { colorScheme, data } = this.props;
        return getColor({
            colorScheme,
            data,
            index,
            point
        });
    }
    onValueEnter(event) {
        this.setState({
            activeValues: event.value
        });
    }
    onValueLeave() {
        this.setState({
            activeValues: undefined
        });
    }
    renderArea() {
        const { area, id, xScale, yScale, data, interpolation, animated, innerRadius, outerRadius } = this.props;
        return (React.createElement(CloneElement, { element: area, id: `${id}-radial-area`, xScale: xScale, yScale: yScale, animated: animated, color: this.getColor.bind(this), data: data, interpolation: interpolation, outerRadius: outerRadius, innerRadius: innerRadius }));
    }
    renderLine() {
        const { line, xScale, yScale, data, animated, interpolation } = this.props;
        return (React.createElement(CloneElement, { element: line, xScale: xScale, yScale: yScale, animated: animated, interpolation: interpolation, color: this.getColor.bind(this), data: data }));
    }
    renderSymbols() {
        const { xScale, yScale, animated, area, symbols, data } = this.props;
        const { activeValues } = this.state;
        // Animations are only valid for Area
        const activeSymbols = (symbols && symbols.props.activeValues) || activeValues;
        const isAnimated = area !== undefined && animated && !activeSymbols;
        return (React.createElement(CloneElement, { element: symbols, activeValues: activeValues, xScale: xScale, yScale: yScale, data: data, animated: isAnimated, color: this.getColor.bind(this) }));
    }
    render() {
        const { area, line, symbols, tooltip, xScale, yScale, data, id, width, height, innerRadius, outerRadius } = this.props;
        return (React.createElement(CloneElement, { element: tooltip, xScale: xScale, yScale: yScale, data: data, height: height, width: width, isRadial: true, innerRadius: innerRadius, outerRadius: outerRadius, color: this.getColor.bind(this), onValueEnter: bind(this.onValueEnter, this), onValueLeave: bind(this.onValueLeave, this) },
            React.createElement("g", { clipPath: `url(#${id}-path)` },
                area && this.renderArea(),
                line && this.renderLine(),
                symbols && this.renderSymbols())));
    }
}
RadialAreaSeries.defaultProps = {
    colorScheme: 'cybertron',
    interpolation: 'smooth',
    animated: true,
    area: React.createElement(RadialArea, null),
    line: React.createElement(RadialLine, null),
    symbols: React.createElement(RadialPointSeries, null),
    tooltip: React.createElement(TooltipArea, null)
};

class RadialAreaChart extends Component {
    constructor() {
        super(...arguments);
        this.getScales = memoize((preData, outerRadius, innerRadius) => {
            const data = buildShallowChartData(preData);
            const yDomain = getYDomain({ data, scaled: false });
            const xDomain = getXDomain({ data });
            const xScale = scaleTime()
                .range([0, 2 * Math.PI])
                .domain(xDomain);
            const yScale = getRadialYScale(innerRadius, outerRadius, yDomain);
            return {
                yScale,
                xScale,
                data
            };
        });
    }
    renderChart(containerProps) {
        const { chartWidth, chartHeight, id } = containerProps;
        const { innerRadius, series, axis } = this.props;
        const outerRadius = Math.min(chartWidth, chartHeight) / 2;
        const { yScale, xScale, data } = this.getScales(this.props.data, outerRadius, innerRadius);
        return (React.createElement(Fragment, null,
            axis && (React.createElement(CloneElement, { element: axis, xScale: xScale, height: chartHeight, width: chartWidth, innerRadius: innerRadius })),
            React.createElement(CloneElement, { element: series, id: id, data: data, xScale: xScale, yScale: yScale, height: chartHeight, width: chartWidth, outerRadius: outerRadius, innerRadius: innerRadius })));
    }
    render() {
        const { id, width, height, margins, className } = this.props;
        return (React.createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: false, yAxisVisible: false, center: true, className: className }, this.renderChart.bind(this)));
    }
}
RadialAreaChart.defaultProps = {
    innerRadius: 80,
    series: React.createElement(RadialAreaSeries, null),
    axis: React.createElement(RadialAxis, null),
    margins: 75
};

var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? Were done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

const MotionBar = (_a) => {
    var { custom, transition, arc } = _a, rest = __rest(_a, ["custom", "transition", "arc"]);
    const d = useMotionValue(custom.exit);
    const prevPath = useMotionValue(custom.exit);
    const spring = useSpring(prevPath, Object.assign(Object.assign({}, DEFAULT_TRANSITION), { from: 0, to: 1 }));
    useEffect(() => {
        const from = custom.previousEnter
            ? custom.previousEnter.y
            : prevPath.get().y;
        const interpolator = interpolate$1(from, custom.enter.y);
        const unsub = spring.onChange(v => d.set(arc(Object.assign(Object.assign({}, custom.enter), { y: interpolator(v) }))));
        prevPath.set(custom.enter);
        return unsub;
    });
    const _b = custom.enter, { d: enterD } = _b, enterRest = __rest(_b, ["d"]);
    const _c = custom.exit, exitRest = __rest(_c, ["d"]);
    return (React.createElement(motion.path, Object.assign({}, rest, { initial: exitRest, exit: exitRest, animate: enterRest, transition: transition, d: transition.type !== false ? d : enterD })));
};

const RadialGuideBar = ({ active, path, fill = '#eee', opacity = 0.2 }) => (React.createElement(motion.path, { d: path, fill: fill, pointerEvents: "none", initial: "hidden", animate: active ? 'visible' : 'hidden', variants: {
        hidden: { opacity: 0 },
        visible: { opacity }
    } }));

class RadialBar extends Component {
    getFill(color) {
        const { id, gradient } = this.props;
        if (!gradient) {
            return color;
        }
        return `url(#${id}-gradient)`;
    }
    onMouseEnter(event) {
        const { onMouseEnter, data } = this.props;
        onMouseEnter({
            value: data,
            nativeEvent: event
        });
    }
    onMouseLeave(event) {
        const { onMouseLeave, data } = this.props;
        onMouseLeave({
            value: data,
            nativeEvent: event
        });
    }
    onMouseClick(event) {
        const { onClick, data } = this.props;
        onClick({
            value: data,
            nativeEvent: event
        });
    }
    getArc(data) {
        const { innerRadius, xScale, yScale, curved } = this.props;
        const outerRadius = yScale(data.y);
        if (curved) {
            const startAngle = xScale(data.x);
            const endAngle = startAngle + xScale.bandwidth();
            const arcFn = arc()
                .innerRadius(innerRadius)
                .outerRadius(outerRadius)
                .startAngle(startAngle)
                .endAngle(endAngle)
                .padAngle(0.01)
                .padRadius(innerRadius);
            return arcFn(data);
        }
        else {
            const startAngle = xScale(data.x) - Math.PI * 0.5;
            const endAngle = startAngle + xScale.bandwidth();
            const innerAngleDistance = endAngle - startAngle;
            const arcLength = innerRadius * innerAngleDistance;
            const outerAngleDistance = arcLength / outerRadius;
            const halfAngleDistanceDelta = (innerAngleDistance - outerAngleDistance) / 2;
            const pathFn = path();
            pathFn.arc(0, 0, innerRadius, startAngle, endAngle);
            pathFn.arc(0, 0, outerRadius, endAngle - halfAngleDistanceDelta, startAngle + halfAngleDistanceDelta, true);
            return pathFn.toString();
        }
    }
    getTransition() {
        const { animated, barCount, index } = this.props;
        if (animated) {
            return Object.assign(Object.assign({}, DEFAULT_TRANSITION), { delay: (index / barCount) * 0.5 });
        }
        else {
            return {
                type: false,
                delay: 0
            };
        }
    }
    renderBar(color) {
        const { className, data, yScale, active, guide } = this.props;
        const fill = this.getFill(color);
        const transition = this.getTransition();
        // Track previous props
        const previousEnter = this.previousEnter
            ? Object.assign({}, this.previousEnter) : undefined;
        this.previousEnter = Object.assign({}, data);
        const [yStart, yEnd] = yScale.domain();
        const exit = Object.assign(Object.assign({}, data), { y: yStart });
        const guidePath = this.getArc(Object.assign(Object.assign({}, data), { y: yEnd }));
        return (React.createElement(Fragment, null,
            guide && (React.createElement(CloneElement, { element: guide, active: active, path: guidePath })),
            React.createElement(MotionBar, { arc: this.getArc.bind(this), custom: {
                    enter: data,
                    exit,
                    previousEnter
                }, transition: transition, fill: fill, className: className, onMouseEnter: bind(this.onMouseEnter, this), onMouseLeave: bind(this.onMouseLeave, this), onClick: bind(this.onMouseClick, this) })));
    }
    render() {
        const { data, index, color, gradient, id, active } = this.props;
        const fill = color(data, index);
        const currentColorShade = active ? chroma(fill).brighten(0.5) : fill;
        return (React.createElement(Fragment, null,
            this.renderBar(currentColorShade),
            gradient && (React.createElement(Gradient, { id: `${id}-gradient`, color: currentColorShade }))));
    }
}
RadialBar.defaultProps = {
    gradient: true,
    curved: false,
    guide: React.createElement(RadialGuideBar, null),
    onClick: () => undefined,
    onMouseEnter: () => undefined,
    onMouseLeave: () => undefined
};

class RadialBarSeries extends Component {
    constructor() {
        super(...arguments);
        this.state = {};
    }
    onValueEnter(event) {
        this.setState({
            activeValues: event.value
        });
    }
    onValueLeave() {
        this.setState({
            activeValues: undefined
        });
    }
    renderBar(point, index) {
        const { innerRadius, xScale, yScale, bar, id, data, animated, colorScheme } = this.props;
        const { activeValues } = this.state;
        const active = activeValues && data && isEqual(activeValues.x, point.x);
        return (React.createElement(Fragment, { key: index },
            React.createElement(CloneElement, { element: bar, id: `radialbar-${id}-${index}`, index: index, data: point, xScale: xScale, active: active, yScale: yScale, innerRadius: innerRadius, color: point => getColor({ data, point, index: 0, colorScheme }), barCount: data.length, animated: animated })));
    }
    render() {
        const { data, id, innerRadius, outerRadius, xScale, yScale, height, width, tooltip, colorScheme } = this.props;
        return (React.createElement(CloneElement, { element: tooltip, xScale: xScale, yScale: yScale, data: data, height: height, width: width, isRadial: true, innerRadius: innerRadius, outerRadius: outerRadius, onValueEnter: this.onValueEnter.bind(this), onValueLeave: this.onValueLeave.bind(this), color: (point, index) => getColor({ data, point, index, colorScheme }) },
            React.createElement("g", { clipPath: `url(#${id}-path)` }, data.map(this.renderBar.bind(this)))));
    }
}
RadialBarSeries.defaultProps = {
    colorScheme: schemes.cybertron[0],
    tooltip: React.createElement(TooltipArea, { tooltip: React.createElement(ChartTooltip, { followCursor: true }) }),
    bar: React.createElement(RadialBar, null),
    animated: true
};

class RadialBarChart extends Component {
    constructor() {
        super(...arguments);
        this.getScales = memoize((preData, innerRadius, outerRadius) => {
            const data = buildShallowChartData(preData);
            const xDomain = uniqueBy(data, d => d.x);
            const yDomain = getYDomain({ data, scaled: false });
            const xScale = scaleBand()
                .range([0, 2 * Math.PI])
                .domain(xDomain);
            const yScale = getRadialYScale(innerRadius, outerRadius, yDomain);
            return {
                xScale,
                yScale,
                data
            };
        });
    }
    renderChart(containerProps) {
        const { chartWidth, chartHeight, id } = containerProps;
        const { innerRadius, series, axis } = this.props;
        const outerRadius = Math.min(chartWidth, chartHeight) / 2;
        const { yScale, xScale, data } = this.getScales(this.props.data, innerRadius, outerRadius);
        return (React.createElement(Fragment, null,
            axis && (React.createElement(CloneElement, { element: axis, xScale: xScale, height: chartHeight, width: chartWidth, innerRadius: innerRadius })),
            React.createElement(CloneElement, { element: series, id: id, data: data, height: chartHeight, width: chartWidth, xScale: xScale, yScale: yScale, innerRadius: innerRadius, outerRadius: outerRadius })));
    }
    render() {
        const { id, width, height, margins, className } = this.props;
        return (React.createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: false, yAxisVisible: false, center: true, className: className }, props => this.renderChart(props)));
    }
}
RadialBarChart.defaultProps = {
    innerRadius: 0.1,
    margins: 75,
    axis: React.createElement(RadialAxis, null),
    series: React.createElement(RadialBarSeries, null)
};

class RadialGaugeArc extends Component {
    getPaths() {
        const { outerRadius, startAngle, endAngle, width, data } = this.props;
        // Calculate the inner rad based on the width
        // and the outer rad which is height/width / 2
        const innerRadius = outerRadius - width;
        // Center arcs so inner/outer align nicely
        const delta = (outerRadius - innerRadius) / 2;
        const newInnerRad = innerRadius + delta;
        const newOuterRad = outerRadius + delta;
        // Create the arc fn to pass to the pie arc
        const innerArc = arc()
            .innerRadius(newInnerRad)
            .outerRadius(newOuterRad);
        return {
            data: {
                startAngle,
                endAngle,
                // Data must be passed
                data: data || {}
            },
            innerArc
        };
    }
    render() {
        const { color, animated, disabled, tooltip, onClick, onMouseEnter, onMouseLeave } = this.props;
        const data = this.getPaths();
        return (React.createElement(PieArc, Object.assign({}, data, { animated: animated, color: color, disabled: disabled, tooltip: tooltip, onClick: onClick, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave })));
    }
}
RadialGaugeArc.defaultProps = {
    width: 5,
    color: '#353d44',
    animated: true,
    disabled: false,
    onClick: () => undefined,
    onMouseEnter: () => undefined,
    onMouseLeave: () => undefined,
    tooltip: React.createElement(ChartTooltip, null)
};

var css$U = ".RadialGaugeLabel-module_valueLabel__1s1YY {\n  font-size: 14px;\n  font-weight: 400;\n  fill: var(--color-on-surface);\n  opacity: .6; }\n";
var css$V = {"valueLabel":"RadialGaugeLabel-module_valueLabel__1s1YY"};
styleInject(css$U);

class RadialGaugeLabel extends PureComponent {
    render() {
        const { data, className, offset, onClick } = this.props;
        const label = formatValue(data.key);
        return (React.createElement("text", { dy: "1.23em", x: "0", y: offset, textAnchor: "middle", onClick: nativeEvent => onClick({ data, nativeEvent }), className: classNames(className, css$V.valueLabel) }, label));
    }
}
RadialGaugeLabel.defaultProps = {
    onClick: () => undefined
};

var css$W = ".RadialGaugeValueLabel-module_valueLabel__1tkTL {\n  font-size: 18px;\n  font-weight: 400;\n  fill: var(--color-on-surface); }\n";
var css$X = {"valueLabel":"RadialGaugeValueLabel-module_valueLabel__1tkTL"};
styleInject(css$W);

class RadialGaugeValueLabel extends PureComponent {
    render() {
        const { data, className } = this.props;
        // TODO: Get seperator based on locale
        return (React.createElement(CountUp, { start: 0, end: data.data, delay: 0, duration: 1, separator: "," }, ({ countUpRef }) => (React.createElement("text", { dy: "-0.5em", x: "0", y: "15", textAnchor: "middle", className: classNames(className, css$X.valueLabel), ref: countUpRef }))));
    }
}
RadialGaugeValueLabel.defaultProps = {};

class RadialGaugeSeries extends Component {
    getWidths() {
        const { data, width, height, minGaugeWidth } = this.props;
        let rows = 1;
        let columns = data.length;
        if (width / data.length < minGaugeWidth) {
            while (width / columns < minGaugeWidth) {
                rows += 1;
                columns = Math.ceil(data.length / rows);
            }
        }
        const xScale = scaleBand();
        xScale.domain(range(columns));
        xScale.rangeRound([0, width], 0.1);
        const yScale = scaleBand();
        yScale.domain(range(rows));
        yScale.rangeRound([0, height], 0.1);
        return {
            columns,
            xScale,
            yScale,
            width: xScale.bandwidth(),
            height: yScale.bandwidth()
        };
    }
    renderGauge(point, index, columns, height, width, xScale, yScale) {
        const { scale, innerArc, outerArc, startAngle, data, endAngle, label, valueLabel, padding, colorScheme } = this.props;
        const dataEndAngle = scale(point.data);
        const baselineLabelHeight = 20;
        const outerRadius = min([
            width - padding,
            height - baselineLabelHeight - padding
        ]) /
            2 -
            10;
        const labelOffset = height / 2 - baselineLabelHeight;
        const x = xScale(index % columns);
        const y = yScale(Math.floor(index / columns));
        const xOffset = x + (width - padding) / 2;
        const yOffset = y + (height - baselineLabelHeight) / 2;
        return (React.createElement("g", { transform: `translate(${xOffset}, ${yOffset})`, key: point.key.toLocaleString() },
            outerArc && (React.createElement(CloneElement, { element: outerArc, outerRadius: outerRadius, startAngle: startAngle, endAngle: endAngle })),
            React.createElement(CloneElement, { element: innerArc, outerRadius: outerRadius, startAngle: startAngle, endAngle: dataEndAngle, data: point, color: getColor({
                    data,
                    colorScheme,
                    point,
                    index
                }) }),
            valueLabel && (React.createElement(CloneElement, { element: valueLabel, data: point })),
            label && (React.createElement(CloneElement, { element: label, data: point, offset: labelOffset }))));
    }
    render() {
        const { data } = this.props;
        const { columns, width, height, xScale, yScale } = this.getWidths();
        return (React.createElement(Fragment, null, data.map((d, i) => this.renderGauge(d, i, columns, height, width, xScale, yScale))));
    }
}
RadialGaugeSeries.defaultProps = {
    outerArc: React.createElement(RadialGaugeArc, { disabled: true }),
    innerArc: React.createElement(RadialGaugeArc, { width: 10, animated: true }),
    label: React.createElement(RadialGaugeLabel, null),
    valueLabel: React.createElement(RadialGaugeValueLabel, null),
    colorScheme: ['#00ECB1'],
    padding: 10,
    minGaugeWidth: 50
};

class RadialGauge extends Component {
    renderChart(containerProps) {
        const { chartWidth, chartHeight } = containerProps;
        const { startAngle, endAngle, minValue, maxValue, data, series } = this.props;
        const scale = scaleLinear()
            .domain([minValue, maxValue])
            .range([startAngle, endAngle]);
        return (React.createElement(CloneElement, { element: series, scale: scale, data: data, startAngle: startAngle, endAngle: endAngle, width: chartWidth, height: chartHeight }));
    }
    render() {
        const { id, width, height, margins, className } = this.props;
        return (React.createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: false, yAxisVisible: false, className: className }, this.renderChart.bind(this)));
    }
}
RadialGauge.defaultProps = {
    minValue: 0,
    maxValue: 100,
    startAngle: 0,
    endAngle: Math.PI * 2,
    series: React.createElement(RadialGaugeSeries, null)
};

var css$Y = ".HeatmapCell-module_cell__1SlIg {\n  -webkit-transition: stroke 150ms ease-in-out;\n  transition: stroke 150ms ease-in-out; }\n";
var css$Z = {"cell":"HeatmapCell-module_cell__1SlIg"};
styleInject(css$Y);

// Set padding modifier for the tooltips
const modifiers$1 = {
    offset: {
        offset: '0, 3px'
    }
};
class HeatmapCell extends Component {
    constructor() {
        super(...arguments);
        this.state = {};
        this.rect = createRef();
    }
    onMouseEnter(event) {
        this.setState({ active: true });
        const { onMouseEnter, data } = this.props;
        onMouseEnter({
            value: data,
            nativeEvent: event
        });
    }
    onMouseLeave(event) {
        this.setState({ active: false });
        const { onMouseLeave, data } = this.props;
        onMouseLeave({
            value: data,
            nativeEvent: event
        });
    }
    onMouseClick(event) {
        const { onClick, data } = this.props;
        onClick({
            value: data,
            nativeEvent: event
        });
    }
    getTooltipData() {
        const { data } = this.props;
        return {
            y: data.value,
            x: `${data.key}  ${data.x}`,
            data
        };
    }
    getTransition() {
        const { animated, cellIndex, cellCount } = this.props;
        if (animated) {
            return Object.assign(Object.assign({}, DEFAULT_TRANSITION), { delay: (cellIndex / cellCount) * 0.005 });
        }
        else {
            return {
                type: false,
                delay: 0
            };
        }
    }
    render() {
        const _a = this.props, { tooltip, onMouseEnter, onMouseLeave, onClick, cellIndex, data, cursor, fill } = _a, rest = __rest(_a, ["tooltip", "onMouseEnter", "onMouseLeave", "onClick", "cellIndex", "data", "cursor", "fill"]);
        const { active } = this.state;
        const extras = constructFunctionProps(this.props, data);
        const isTransparent = fill === 'transparent';
        const stroke = active && !isTransparent ? chroma(fill).brighten(1) : fill;
        const transition = this.getTransition();
        return (React.createElement(Fragment, null,
            React.createElement("g", { ref: this.rect },
                React.createElement(motion.rect, Object.assign({}, rest, { fill: fill, stroke: stroke, style: Object.assign(Object.assign({}, extras.style), { cursor }), className: classNames(css$Z.cell, extras.className), initial: {
                        opacity: 0
                    }, animate: {
                        opacity: 1
                    }, exit: {
                        opacity: 0
                    }, transition: transition, onMouseEnter: bind(this.onMouseEnter, this), onMouseLeave: bind(this.onMouseLeave, this), onClick: bind(this.onMouseClick, this) }))),
            tooltip && !tooltip.props.disabled && !isTransparent && (React.createElement(CloneElement, { element: tooltip, visible: !!active, modifiers: tooltip.props.modifiers || modifiers$1, reference: this.rect, value: this.getTooltipData() }))));
    }
}
HeatmapCell.defaultProps = {
    rx: 2,
    ry: 2,
    cursor: 'auto',
    tooltip: React.createElement(ChartTooltip, null),
    onClick: () => undefined,
    onMouseEnter: () => undefined,
    onMouseLeave: () => undefined
};

class HeatmapSeries extends Component {
    constructor() {
        super(...arguments);
        this.getValueScale = memoize((data, colorScheme, emptyColor) => {
            const valueDomain = extent$1(uniqueBy(data, d => d.data, d => d.value));
            return point => {
                // For 0 values, lets show a placeholder fill
                if (point === undefined || point === null) {
                    return emptyColor;
                }
                return getColor({
                    scale: scaleQuantile,
                    domain: valueDomain,
                    key: point,
                    colorScheme
                });
            };
        });
    }
    renderCell({ row, cell, rowIndex, cellIndex, valueScale, width, height, cellCount }) {
        const { xScale, yScale, id, animated, cell: cellElement } = this.props;
        const x = xScale(row.key);
        const y = yScale(cell.x);
        const fill = valueScale(cell.value);
        return (React.createElement(CloneElement, { key: `${id}-${rowIndex}-${cellIndex}`, element: cellElement, animated: animated, cellIndex: rowIndex + cellIndex, cellCount: cellCount, x: x, y: y, fill: fill, width: width, height: height, data: cell }));
    }
    render() {
        const { xScale, yScale, data, colorScheme, emptyColor } = this.props;
        const valueScale = this.getValueScale(data, colorScheme, emptyColor);
        const height = yScale.bandwidth();
        const width = xScale.bandwidth();
        const cellCount = sum([...yScale.domain(), ...xScale.domain()]);
        return (React.createElement(Fragment, null, data.map((row, rowIndex) => row.data.map((cell, cellIndex) => this.renderCell({
            height,
            width,
            valueScale,
            cellCount,
            row,
            cell,
            rowIndex,
            cellIndex
        })))));
    }
}
HeatmapSeries.defaultProps = {
    padding: 0.1,
    animated: true,
    emptyColor: 'rgba(200,200,200,0.08)',
    colorScheme: ['rgba(28, 107, 86, 0.5)', '#2da283'],
    cell: React.createElement(HeatmapCell, null)
};

class Heatmap extends Component {
    getScalesData(chartHeight, chartWidth) {
        const { xAxis, yAxis, series, data: prevData } = this.props;
        const data = buildNestedChartData(prevData);
        const xDomain = xAxis.props.domain ||
            uniqueBy(data, d => d.key);
        const xScale = scaleBand()
            .range([0, chartWidth])
            .domain(xDomain)
            .paddingInner(series.props.padding);
        const yDomain = yAxis.props.domain ||
            uniqueBy(data, d => d.data, d => d.x);
        const yScale = scaleBand()
            .domain(yDomain)
            .range([chartHeight, 0])
            .paddingInner(series.props.padding);
        return {
            yScale,
            xScale,
            data
        };
    }
    renderChart(containerProps) {
        const { chartWidth, chartHeight, updateAxes, id } = containerProps;
        const { yAxis, xAxis, series, secondaryAxis } = this.props;
        const { xScale, yScale, data } = this.getScalesData(chartHeight, chartWidth);
        return (React.createElement(Fragment, null,
            React.createElement(CloneElement, { element: xAxis, height: chartHeight, width: chartWidth, scale: xScale, onDimensionsChange: bind(updateAxes, this, 'horizontal') }),
            React.createElement(CloneElement, { element: yAxis, height: chartHeight, width: chartWidth, scale: yScale, onDimensionsChange: bind(updateAxes, this, 'vertical') }),
            secondaryAxis &&
                secondaryAxis.map((axis, i) => (React.createElement(CloneElement, { key: i, element: axis, height: chartHeight, width: chartWidth, onDimensionsChange: bind(updateAxes, this, 'horizontal') }))),
            React.createElement(CloneElement, { element: series, id: `heat-series-${id}`, data: data, xScale: xScale, yScale: yScale })));
    }
    render() {
        const { id, width, height, margins, className, xAxis, yAxis } = this.props;
        return (React.createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: isAxisVisible(xAxis.props), yAxisVisible: isAxisVisible(yAxis.props), className: classNames(className) }, props => this.renderChart(props)));
    }
}
Heatmap.defaultProps = {
    data: [],
    margins: 10,
    series: React.createElement(HeatmapSeries, null),
    yAxis: (React.createElement(LinearYAxis, { type: "category", axisLine: null, tickSeries: React.createElement(LinearYAxisTickSeries, { line: null, label: React.createElement(LinearYAxisTickLabel, { padding: 5 }) }) })),
    xAxis: (React.createElement(LinearXAxis, { type: "category", axisLine: null, tickSeries: React.createElement(LinearXAxisTickSeries, { line: null, label: React.createElement(LinearXAxisTickLabel, { padding: 5 }) }) }))
};

const getFirstOfMonth = (date) => new Date(date.getFullYear(), date.getMonth(), 1);
const addWeeksToDate = (date, weeks) => {
    let d = new Date(date.getTime());
    d.setDate(d.getDate() + weeks * 7);
    return d;
};
const getStartOfDay = (date) => {
    const d = new Date(date.getTime());
    d.setHours(0, 0, 0, 0);
    return d;
};
const getNewDayFromDay = (date, num) => {
    const d = new Date(date.getTime());
    d.setDate(d.getDate() + num);
    return d;
};
const weekDays = (() => {
    const base = new Date(Date.UTC(2017, 0, 2));
    return range(7).map(() => {
        const name = base.toLocaleDateString('default', { weekday: 'short' });
        base.setDate(base.getDate() + 1);
        return name;
    });
})();
const buildDataScales = (rawData, view) => {
    // Get the most recent date to get the range from
    // From the end date, lets find the start year/month of that
    // From that start year/month, lets find the end year/month for our bounds
    const startDate = min(rawData, d => d.key);
    const start = getFirstOfMonth(startDate);
    const endDomain = view === 'year' ? 53 : 5;
    const end = addWeeksToDate(start, endDomain);
    // Base on the view type, swap out some ranges
    const xDomainRange = view === 'year' ? 53 : 5;
    // Build our x/y domains for days of week + number of weeks in year
    const yDomain = range(7).reverse();
    const xDomain = range(xDomainRange);
    // Filter out dates that are not in the start/end ranges
    // and turn them into something our chart can read
    const dates = rawData
        .filter(d => d.key.getTime() > start.getTime() ||
        d.key.getTime() < end.getTime())
        .map(d => ({
        key: getStartOfDay(d.key),
        data: d.data
    }));
    // Find the first day of the duration and subtract the delta
    const firstDayOfStart = start.getDay();
    const curDate = getNewDayFromDay(start, -firstDayOfStart);
    const rows = [];
    // Build out the dataset for the n duration
    for (let week = 0; week < xDomainRange; week++) {
        const row = {
            key: week,
            data: []
        };
        for (let day = 0; day <= 6; day++) {
            const dayValue = dates.find(d => d.key.getTime() === curDate.getTime());
            row.data.push({
                key: day,
                data: dayValue ? dayValue.data : undefined,
                metadata: {
                    date: new Date(curDate.getTime()),
                    start: start,
                    end: end
                }
            });
            curDate.setDate(curDate.getDate() + 1);
        }
        rows.push(row);
    }
    return {
        data: rows,
        yDomain,
        xDomain,
        start
    };
};

class CalendarHeatmap extends Component {
    constructor() {
        super(...arguments);
        this.getDataDomains = memoize((rawData, view) => buildDataScales(rawData, view));
    }
    render() {
        const _a = this.props, { data: rawData, view } = _a, rest = __rest(_a, ["data", "view"]);
        const { data, yDomain, xDomain, start } = this.getDataDomains(rawData, view);
        // For month, only pass 1 tick value
        const xTickValues = view === 'year' ? undefined : [1];
        // Get the yAxis label formatting based on view type
        const yAxisLabelFormat = view === 'year' ? d => weekDays[d] : () => null;
        // Format the xAxis label for the start + n week
        const xAxisLabelFormat = d => addWeeksToDate(start, d).toLocaleString('default', { month: 'long' });
        return (React.createElement(Heatmap, Object.assign({}, rest, { data: data, yAxis: React.createElement(LinearYAxis, { type: "category", axisLine: null, domain: yDomain, tickSeries: React.createElement(LinearYAxisTickSeries, { tickSize: 20, line: null, label: React.createElement(LinearYAxisTickLabel, { padding: 5, format: yAxisLabelFormat }) }) }), xAxis: React.createElement(LinearXAxis, { type: "category", axisLine: null, domain: xDomain, tickSeries: React.createElement(LinearXAxisTickSeries, { line: null, tickValues: xTickValues, label: React.createElement(LinearXAxisTickLabel, { padding: 5, align: "end", format: xAxisLabelFormat }) }) }) })));
    }
}
CalendarHeatmap.defaultProps = {
    view: 'year',
    series: (React.createElement(HeatmapSeries, { padding: 0.3, emptyColor: 'transparent', cell: React.createElement(HeatmapCell, { tooltip: React.createElement(ChartTooltip, { content: d => `${formatValue(d.data.metadata.date)}  ${formatValue(d.data.value)}` }) }) }))
};

const LinearGaugeBar = props => (React.createElement(Bar, Object.assign({}, props, { rounded: false, tooltip: React.createElement(ChartTooltip, { placement: "top", content: data => (React.createElement(TooltipTemplate, { value: { y: data.value, x: data.y } })) }) })));

const LinearGaugeOuterBar = (_a) => {
    var { height, width, fill } = _a, rest = __rest(_a, ["height", "width", "fill"]);
    return React.createElement("rect", Object.assign({}, rest, { fill: fill || '#484848', width: width, height: height }));
};

const defaultProps = {
    outerBar: React.createElement(LinearGaugeOuterBar, null),
    bar: React.createElement(LinearGaugeBar, null)
};
const LinearGaugeSeries = (_a) => {
    var { height, width, bar, outerBar, isMultiSeries } = _a, rest = __rest(_a, ["height", "width", "bar", "outerBar", "isMultiSeries"]);
    return (React.createElement(Fragment, null,
        !isMultiSeries && (React.createElement(CloneElement, { element: outerBar || defaultProps.outerBar, height: height, width: width })),
        React.createElement(BarSeries, Object.assign({}, rest, { layout: "horizontal", tooltip: null, bar: React.createElement(CloneElement, { element: bar || defaultProps.bar }) }))));
};

class LinearGauge extends Component {
    getData(data) {
        if (Array.isArray(data)) {
            return buildBarStackData([
                {
                    key: 'default',
                    data
                }
            ], 'expand', 'horizontal');
        }
        else {
            return buildShallowChartData([data], 'horizontal');
        }
    }
    getScales(isMultiSeries, data, width, height, minValue, maxValue) {
        const domain = !isMultiSeries ? [minValue, maxValue] : undefined;
        const keyScale = getXScale({
            width,
            type: 'value',
            data,
            domain,
            isMultiSeries
        });
        const valueScale = getYScale({
            type: 'category',
            height,
            data,
            isMultiSeries
        });
        return {
            keyScale,
            valueScale
        };
    }
    renderChart({ chartHeight, chartWidth, id, chartSized }) {
        const { series, data, minValue, maxValue } = this.props;
        const isMultiSeries = Array.isArray(data);
        const type = isMultiSeries ? 'stackedNormalized' : 'standard';
        const transformedData = this.getData(data);
        const { keyScale, valueScale } = this.getScales(isMultiSeries, transformedData, chartWidth, chartHeight, minValue, maxValue);
        return (React.createElement(Fragment, null, chartSized && (React.createElement(CloneElement, { element: series, id: `linear-gauge-series-${id}`, data: transformedData, isCategorical: true, xScale: keyScale, yScale: valueScale, type: type, height: chartHeight, width: chartWidth, isMultiSeries: isMultiSeries }))));
    }
    render() {
        const { id, width, height, margins, className } = this.props;
        return (React.createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, className: className }, props => this.renderChart(props)));
    }
}
LinearGauge.defaultProps = {
    minValue: 0,
    maxValue: 100,
    series: React.createElement(LinearGaugeSeries, null)
};

export { Area, AreaChart, AreaSeries, AreaSparklineChart, Bar, BarChart, BarLabel, BarSeries, BarSparklineChart, Brush, BrushSlice, CalendarHeatmap, ChartBrush, ChartContainer, ChartTooltip, ChartZoomPan, CloneElement, DEFAULT_TRANSITION, DiscreteLegend, DiscreteLegendEntry, DiscreteLegendSymbol, Gradient, GradientStop, GridStripe, Gridline, GridlineSeries, GuideBar, Heatmap, HeatmapCell, HeatmapSeries, HistogramBarChart, HistogramBarSeries, HivePlot, Line, LineChart, LineSeries, LinearAxis, LinearAxisLine, LinearAxisTickLabel, LinearAxisTickLine, LinearAxisTickSeries, LinearGauge, LinearGaugeBar, LinearGaugeOuterBar, LinearGaugeSeries, LinearXAxis, LinearXAxisTickLabel, LinearXAxisTickLine, LinearXAxisTickSeries, LinearYAxis, LinearYAxisTickLabel, LinearYAxisTickLine, LinearYAxisTickSeries, Map$1 as Map, MapMarker, MarimekkoBarSeries, MarimekkoChart, MarkLine, Mask, MotionPath, Move, Pan, PieArc, PieArcLabel, PieArcSeries, PieChart, PointSeries, RadialArea, RadialAreaChart, RadialAreaSeries, RadialAxis, RadialAxisArc, RadialAxisArcSeries, RadialAxisTick, RadialAxisTickLabel, RadialAxisTickLine, RadialAxisTickSeries, RadialBar, RadialBarChart, RadialBarSeries, RadialGauge, RadialGaugeArc, RadialGaugeLabel, RadialGaugeSeries, RadialGaugeValueLabel, RadialGradient, RadialGuideBar, RadialLine, RadialPointSeries, RadialScatterPlot, RadialScatterPoint, RadialScatterSeries, RangeLines, ResizeContainer, Sankey, SankeyLabel, SankeyLink, SankeyNode, ScatterPlot, ScatterPoint, ScatterSeries, SequentialLegend, SonarChart, SparklineChart, StackedAreaChart, StackedAreaSeries, StackedBarChart, StackedBarSeries, StackedNormalizedAreaChart, StackedNormalizedAreaSeries, StackedNormalizedBarChart, StackedNormalizedBarSeries, Stripes, Tooltip, TooltipArea, TooltipTemplate, Zoom, ZoomPan, addWeeksToDate, bigIntegerToLocaleString, buildBarStackData, buildBins, buildDataScales, buildMarimekkoData, buildNestedChartData, buildShallowChartData, buildStackData, buildWaterfall, calculateDimensions, calculateShowStroke, constrainMatrix, constructFunctionProps, extent, formatValue, functionProps, getClosestPoint, getColor, getDegrees, getDimension, getDurationTicks, getLimitMatrix, getMaxBigIntegerForNested, getMaxBigIntegerForShallow, getMaxTicks, getParentSVG, getPointFromMatrix, getPositionForTarget, getTicks, getXDomain, getYDomain, humanFormatBigInteger, interpolate, isAxisVisible, isZoomLevelGoingOutOfBounds, normalizeValue, normalizeValueForFormatting, reduceTicks, schemes, toggleTextSelection, uniqueBy, weekDays };

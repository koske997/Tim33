(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom'), require('classnames'), require('framer-motion'), require('react-scrolllock'), require('memoize-bind'), require('popper.js')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom', 'classnames', 'framer-motion', 'react-scrolllock', 'memoize-bind', 'popper.js'], factory) :
  (global = global || self, factory(global.rdk = {}, global.React, global.reactDom, global.classNames, global.framerMotion, global.ScrollLock, global.bind, global.PopperJS));
}(this, (function (exports, React, reactDom, classNames, framerMotion, ScrollLock, bind, PopperJS) { 'use strict';

  var React__default = 'default' in React ? React['default'] : React;
  classNames = classNames && classNames.hasOwnProperty('default') ? classNames['default'] : classNames;
  ScrollLock = ScrollLock && ScrollLock.hasOwnProperty('default') ? ScrollLock['default'] : ScrollLock;
  bind = bind && bind.hasOwnProperty('default') ? bind['default'] : bind;
  PopperJS = PopperJS && PopperJS.hasOwnProperty('default') ? PopperJS['default'] : PopperJS;

  class ExitListener extends React.Component {
      constructor() {
          super(...arguments);
          this.node = null;
          this.onDocumentClick = (event) => {
              if (event.which !== 3) {
                  const contentContains = this.node && this.node.contains(event.target);
                  if (!contentContains && this.props.onClickOutside) {
                      this.props.onClickOutside(event);
                  }
              }
          };
          this.onDocumentKeydown = (event) => {
              if (event.keyCode === 27 && this.props.onEscape) {
                  this.props.onEscape(event);
              }
          };
      }
      componentDidMount() {
          this.node = reactDom.findDOMNode(this);
          if (this.props.onClickOutside) {
              document.addEventListener('mousedown', this.onDocumentClick);
          }
          if (this.props.onEscape) {
              document.addEventListener('keydown', this.onDocumentKeydown);
          }
      }
      componentWillUnmount() {
          document.removeEventListener('mousedown', this.onDocumentClick);
          document.removeEventListener('keydown', this.onDocumentKeydown);
      }
      render() {
          return this.props.children;
      }
  }

  class Portal extends React.PureComponent {
      constructor() {
          super(...arguments);
          this.defaultNode = null;
      }
      componentWillUnmount() {
          if (this.defaultNode) {
              document.body.removeChild(this.defaultNode);
              this.props.onUnmount();
          }
          this.defaultNode = null;
      }
      render() {
          if (!this.defaultNode) {
              this.defaultNode = document.createElement('div');
              document.body.appendChild(this.defaultNode);
              this.props.onMount();
          }
          return reactDom.createPortal(this.props.children, this.defaultNode);
      }
  }
  Portal.defaultProps = {
      onMount: () => undefined,
      onUnmount: () => undefined
  };

  const portals = [];
  const START_INDEX = 990;
  class OverlayPortal extends React.Component {
      componentDidMount() {
          portals.push(this);
      }
      componentWillUnmount() {
          portals.splice(portals.indexOf(this), 1);
      }
      getIndexes() {
          let portalIndex = portals.indexOf(this);
          if (portalIndex === -1) {
              portalIndex = 0;
          }
          const overlayIndex = START_INDEX + portalIndex * 2 + 1;
          return {
              portalIndex,
              overlayIndex,
              backdropIndex: overlayIndex
          };
      }
      render() {
          const { onMount, onUnmount } = this.props;
          const render = this.props.children || this.props.render;
          const { portalIndex, backdropIndex, overlayIndex } = this.getIndexes();
          return (React__default.createElement(Portal, { onMount: onMount, onUnmount: onUnmount }, render({ overlayIndex, portalIndex, backdropIndex })));
      }
  }
  OverlayPortal.defaultProps = {
      onMount: () => undefined,
      onUnmount: () => undefined,
      onOverlayClick: () => undefined
  };

  function styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css = ".Backdrop-module_backdrop__3znpY {\n  position: fixed;\n  background: var(--color-layer-transparent);\n  top: 0;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  opacity: 0;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none; }\n";
  var css$1 = {"backdrop":"Backdrop-module_backdrop__3znpY"};
  styleInject(css);

  class Backdrop extends React.PureComponent {
      render() {
          const { visible, onClick, zIndex, className, portalIndex } = this.props;
          return (React__default.createElement(framerMotion.AnimatePresence, null, visible && (React__default.createElement(framerMotion.motion.div, { className: classNames(css$1.backdrop, className), initial: { opacity: 0 }, animate: { opacity: (0.8 - (portalIndex / 10)) }, exit: { opacity: 0 }, onClick: onClick, style: { zIndex } }))));
      }
  }
  Backdrop.defaultProps = {
      onClick: () => undefined,
      portalIndex: 0,
      zIndex: 998,
      visible: false,
      className: 'backdrop'
  };

  const OverlayContext = React.createContext({
      close: () => undefined
  });

  class GlobalOverlay extends React.Component {
      constructor(props) {
          super(props);
          this.state = {
              open: props.open
          };
      }
      componentDidUpdate(prevProps) {
          const { open, onClose } = this.props;
          if (open !== prevProps.open && this.state.open !== open) {
              this.setState({ open });
              if (!open && onClose) {
                  onClose();
              }
          }
      }
      onBackdropClick() {
          if (this.props.closeOnBackdropClick) {
              this.close();
          }
      }
      close() {
          this.setState({ open: false });
          if (this.props.onClose) {
              this.props.onClose();
          }
      }
      render() {
          const { hasBackdrop, children, render, backdropClassName, closeOnEscape } = this.props;
          const { open } = this.state;
          const renderFn = children || render;
          return (React__default.createElement(OverlayContext.Provider, { value: {
                  close: bind(this.close, this)
              } },
              React__default.createElement(framerMotion.AnimatePresence, null, open && (React__default.createElement(React.Fragment, null,
                  React__default.createElement(OverlayPortal, null, ({ overlayIndex, backdropIndex, portalIndex }) => (React__default.createElement(React.Fragment, null,
                      hasBackdrop && (React__default.createElement(Backdrop, { zIndex: backdropIndex, portalIndex: portalIndex, visible: open, onClick: bind(this.onBackdropClick, this), className: classNames(backdropClassName) })),
                      React__default.createElement(ExitListener, { onEscape: closeOnEscape ? bind(this.close, this) : null }, renderFn({ overlayIndex }))))),
                  React__default.createElement(ScrollLock, null))))));
      }
  }
  GlobalOverlay.defaultProps = {
      hasBackdrop: true,
      closeOnEscape: true,
      closeOnBackdropClick: true,
      onClose: () => undefined
  };

  class OverlayTrigger extends React.Component {
      constructor() {
          super(...arguments);
          this.element = null;
      }
      hasTrigger(type) {
          const triggers = this.props.trigger;
          if (Array.isArray(triggers)) {
              return triggers.includes(type);
          }
          else {
              return type === triggers;
          }
      }
      onFocus(event) {
          this.activate({ type: 'focus', nativeEvent: event });
      }
      onBlur(event) {
          this.deactivate({ type: 'focus', nativeEvent: event });
      }
      onMouseEnter(event) {
          this.activate({ type: 'hover', nativeEvent: event });
      }
      onMouseLeave(event) {
          this.deactivate({ type: 'hover', nativeEvent: event });
      }
      onClick(event) {
          this.activate({ type: 'click', nativeEvent: event });
          // Kill the tooltip on click if its not a click listener
          if (!this.hasTrigger('click')) {
              this.props.onDeactivate({ type: 'hover', nativeEvent: event });
          }
      }
      activate({ type, nativeEvent }) {
          const { onActivate } = this.props;
          if (this.hasTrigger(type)) {
              onActivate({ type, nativeEvent });
          }
      }
      deactivate({ type, nativeEvent }) {
          const { onDeactivate } = this.props;
          if (this.hasTrigger(type)) {
              onDeactivate({ type, nativeEvent });
          }
      }
      render() {
          const { children, className } = this.props;
          const tabIndex = this.hasTrigger('focus') ? -1 : undefined;
          return (React__default.createElement("span", { tabIndex: tabIndex, ref: ref => (this.element = ref), onMouseEnter: bind(this.onMouseEnter, this), onMouseLeave: bind(this.onMouseLeave, this), onFocus: bind(this.onFocus, this), onBlur: bind(this.onBlur, this), onClick: bind(this.onClick, this), className: classNames(className) }, children));
      }
  }

  var container = "Position-module_container__2OGTq";
  var css$2 = ".Position-module_container__2OGTq {\n  pointer-events: none; }\n  .Position-module_container__2OGTq > * {\n    pointer-events: initial; }\n";
  styleInject(css$2);

  class Position extends React.Component {
      constructor() {
          super(...arguments);
          this.mouse = { pageX: 0, pageY: 0 };
          this.onMouseMove = ({ pageX, pageY }) => {
              this.mouse = { pageX, pageY };
              if (this.popperInstance) {
                  this.popperInstance.scheduleUpdate();
              }
          };
      }
      componentDidUpdate(prevProps) {
          if (this.props.reference !== prevProps.reference && this.popperInstance) {
              this.popperInstance.destroy();
              this.popperInstance = undefined;
              this.createPopper();
          }
      }
      componentWillUnmount() {
          if (this.popperInstance) {
              this.popperInstance.destroy();
          }
          if (this.props.followCursor) {
              window.removeEventListener('mousemove', this.onMouseMove);
          }
      }
      updatePosition() {
          if (this.popperInstance) {
              this.popperInstance.scheduleUpdate();
          }
      }
      getReference() {
          const { reference, followCursor } = this.props;
          const referenceElement = reference;
          if (followCursor) {
              return {
                  getBoundingClientRect: () => ({
                      top: this.mouse.pageY,
                      right: this.mouse.pageX,
                      bottom: this.mouse.pageY,
                      left: this.mouse.pageX,
                      width: 0,
                      height: 0
                  }),
                  clientWidth: 0,
                  clientHeight: 0
              };
          }
          else if (referenceElement && !referenceElement.getBoundingClientRect) {
              const { top, left, width, height } = reference;
              return {
                  getBoundingClientRect: () => ({
                      top,
                      left,
                      width,
                      bottom: top - height,
                      right: left - width,
                      height
                  }),
                  clientWidth: width,
                  clientHeight: height
              };
          }
          return referenceElement;
      }
      createPopper(element = this.element) {
          this.element = element;
          if (!this.popperInstance && element) {
              const { placement, modifiers, followCursor } = this.props;
              const reference = this.getReference();
              if (reference) {
                  window.removeEventListener('mousemove', this.onMouseMove);
                  this.popperInstance = new PopperJS(reference, this.element, {
                      placement,
                      modifiers,
                      onCreate: () => {
                          if (followCursor) {
                              window.addEventListener('mousemove', this.onMouseMove);
                          }
                      }
                  });
              }
          }
      }
      render() {
          const { className, style, children } = this.props;
          return (React__default.createElement("span", { ref: elm => this.createPopper(elm), className: classNames(className, container), style: style }, children));
      }
  }
  Position.defaultProps = {
      placement: 'top',
      modifiers: {}
  };

  class ConnectedOverlay extends React__default.Component {
      constructor() {
          super(...arguments);
          this.triggerRef = null;
          this.positionRef = null;
      }
      getReference() {
          const { reference } = this.props;
          if (reference) {
              if (reference.current) {
                  return reference.current;
              }
              return reference;
          }
          else if (this.triggerRef) {
              return this.triggerRef.element;
          }
      }
      onClickOutside(event) {
          const { onDeactivate, closeOnBodyClick } = this.props;
          if (closeOnBodyClick && onDeactivate) {
              onDeactivate({
                  type: 'click',
                  nativeEvent: event
              });
          }
      }
      onEscape(event) {
          const { onDeactivate, closeOnEscape } = this.props;
          if (closeOnEscape && onDeactivate) {
              onDeactivate({
                  type: 'key',
                  nativeEvent: event
              });
          }
      }
      updatePosition() {
          if (this.positionRef) {
              this.positionRef.updatePosition();
          }
      }
      renderContent() {
          const { placement, modifiers, content, followCursor, zIndex } = this.props;
          const reference = this.getReference();
          return (React__default.createElement(Position, { style: { zIndex }, reference: reference, placement: placement, modifiers: modifiers, followCursor: followCursor, ref: ref => (this.positionRef = ref) },
              React__default.createElement(ExitListener, { onClickOutside: bind(this.onClickOutside, this), onEscape: bind(this.onEscape, this) }, content())));
      }
      render() {
          const { children, trigger, visible, onActivate, onDeactivate, appendToBody } = this.props;
          return (React__default.createElement(React.Fragment, null,
              children && trigger && onActivate && onDeactivate && (React__default.createElement(OverlayTrigger, { trigger: trigger, onActivate: onActivate, onDeactivate: onDeactivate, ref: ref => (this.triggerRef = ref) }, children)),
              children && !trigger && children,
              React__default.createElement(framerMotion.AnimatePresence, null, visible && (React__default.createElement(React.Fragment, null,
                  appendToBody && (React__default.createElement(Portal, null, this.renderContent())),
                  !appendToBody && this.renderContent())))));
      }
  }
  ConnectedOverlay.defaultProps = {
      closeOnBodyClick: true,
      closeOnEscape: true,
      appendToBody: true,
      zIndex: 9999
  };

  exports.Backdrop = Backdrop;
  exports.ConnectedOverlay = ConnectedOverlay;
  exports.ExitListener = ExitListener;
  exports.GlobalOverlay = GlobalOverlay;
  exports.OverlayContext = OverlayContext;
  exports.OverlayPortal = OverlayPortal;
  exports.OverlayTrigger = OverlayTrigger;
  exports.Portal = Portal;
  exports.Position = Position;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
